'use client'
import { __awaiter } from '../../_virtual/_tslib.js';
import { MetaMaskSDK } from '@metamask/sdk';
import { createWalletClient, custom, isHex, toHex } from 'viem';
import { EthereumWalletConnector, getOrMapViemChain } from '@dynamic-labs/ethereum-core';
import { eventListenerHandlers } from '@dynamic-labs/wallet-connector-core';
import { createEventTimeline, PlatformService, isMobile, retryableFn } from '@dynamic-labs/utils';
import { getWalletBookWallet, findWalletBookWallet } from '@dynamic-labs/wallet-book';
import { logger } from '../utils/logger.js';
import { EthProviderHelper } from '../ethProviderHelper.js';
import { createMetaMaskSDKDisplayUriState } from './utils/createMetaMaskSDKDisplayUriState.js';
import { waitForConnection } from './utils/waitForConnection.js';
import { isPendingWalletRequestPermissionError } from './utils/isPendingWalletRequestPermissionError.js';

/**
 * The MetaMask SDK must be initialized only once, so we store the instance
 * in these variables to avoid initializing it multiple times
 */
let _metaMaskSDK = null;
let _metaMaskSDKDisplayUriState = null;
const eventTimeline = createEventTimeline();
class MetaMaskConnector extends EthereumWalletConnector {
    constructor(props) {
        super(props);
        this.name = 'MetaMask';
        this.overrideKey = 'metamask';
        this.canConnectViaQrCode = true;
        this.isInAppBrowser = false;
        this.appName = props.appName;
        this.appLogoUrl = props.appLogoUrl;
        /**
         * The isInAppBrowser must be calculated before initializing the MetaMask SDK.
         *
         * The isInAppBrowser is calculated by checking if the window provider is installed
         * in the browser and if it is running on a mobile device.
         *
         * But the MetaMask SDK will inject its own provider to the window if not provider is injected.
         * This means the MetaMask SDK can interfere with the isInAppBrowser calculation.
         *
         * So we need to calculate the isInAppBrowser before initializing the MetaMask SDK
         * to prevent a false negative
         */
        this.isInAppBrowser = this.getIsInAppBrowser();
        if (!_metaMaskSDK) {
            this.createMetaMaskSDK();
        }
    }
    getSupportedNetworks() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.evmNetworks.map((network) => network.chainId.toString());
        });
    }
    get ethProviderHelper() {
        return new EthProviderHelper(getWalletBookWallet(this.walletBook, this.key));
    }
    get metaMaskSDK() {
        if (!_metaMaskSDK)
            throw new Error('MetaMaskSDK not initialized');
        return _metaMaskSDK;
    }
    set metaMaskSDK(metaMaskSDK) {
        _metaMaskSDK = metaMaskSDK;
    }
    get metaMaskSDKDisplayUriState() {
        if (!_metaMaskSDKDisplayUriState)
            throw new Error('MetaMaskSDKDisplayUriState not initialized');
        return _metaMaskSDKDisplayUriState;
    }
    createMetaMaskSDK() {
        const dappMetadata = {
            iconUrl: this.appLogoUrl,
            name: this.appName,
            url: PlatformService.getOrigin(),
        };
        _metaMaskSDK = new MetaMaskSDK({
            _source: 'dynamic-labs',
            checkInstallationImmediately: true,
            dappMetadata,
            enableAnalytics: true,
            extensionOnly: this.isInstalledOnBrowser(),
            headless: true,
            openDeeplink: PlatformService.openURL,
            preferDesktop: !isMobile(),
            readonlyRPCMap: getReadonlyRPCMap(this.evmNetworkRpcMap()),
            useDeeplink: true,
        });
        _metaMaskSDKDisplayUriState =
            createMetaMaskSDKDisplayUriState(_metaMaskSDK);
    }
    endSession() {
        return __awaiter(this, void 0, void 0, function* () {
            eventTimeline.postEvent('disconnect');
            /**
             * The MetaMask SDK must be terminated and reinitialized on mobile
             * to prevent deeplinks not working
             */
            if (isMobile()) {
                return this.metaMaskSDK.terminate().then(() => {
                    _metaMaskSDK = null;
                    _metaMaskSDKDisplayUriState = null;
                    return this.createMetaMaskSDK();
                });
            }
            /**
             * Just terminate the SDK on desktop
             */
            return this.metaMaskSDK.terminate();
        });
    }
    getAddress(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                var _a, _b, _c, _d;
                // QR Code flow
                if (!isMobile() && Boolean(opts === null || opts === void 0 ? void 0 : opts.onDisplayUri)) {
                    this.metaMaskSDKDisplayUriState
                        .consumeDisplayUri()
                        .then((displayUri) => {
                        var _a;
                        if (!displayUri) {
                            reject(new Error('MetaMask display uri not found'));
                            return;
                        }
                        (_a = opts === null || opts === void 0 ? void 0 : opts.onDisplayUri) === null || _a === void 0 ? void 0 : _a.call(opts, displayUri);
                    });
                }
                // Deep link to MetaMask app in-app browser
                if (this.shouldDeepLinkToMetaMaskInAppBrowser() &&
                    ((_b = (_a = this.wallet) === null || _a === void 0 ? void 0 : _a.mobile) === null || _b === void 0 ? void 0 : _b.inAppBrowser)) {
                    // Redirect to the in-app browser and append the current url
                    window.location.href = `${(_d = (_c = this.wallet) === null || _c === void 0 ? void 0 : _c.mobile) === null || _d === void 0 ? void 0 : _d.inAppBrowser}/${window.location.href}`;
                    resolve(undefined);
                    return;
                }
                // Connect to MetaMask
                this.getConnectedAccountsSafely().then((initialConnectedAccounts) => __awaiter(this, void 0, void 0, function* () {
                    if (initialConnectedAccounts.length) {
                        resolve(initialConnectedAccounts[0]);
                        return;
                    }
                    try {
                        yield this.metaMaskSDK.connect();
                    }
                    catch (error) {
                        const isRequestPendingError = isPendingWalletRequestPermissionError(error);
                        if (!isRequestPendingError) {
                            throw error;
                        }
                        else {
                            yield waitForConnection(this.getProvider());
                        }
                    }
                    const accounts = yield this.getConnectedAccounts();
                    resolve(accounts[0]);
                }));
            });
        });
    }
    getConnectedAccountsSafely() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const connectedAccounts = yield this.getConnectedAccounts();
                return connectedAccounts;
            }
            catch (err) {
                logger.error(err);
                return [];
            }
        });
    }
    getConnectedAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            // Wait for for MetaMask SDK to initialize
            yield this.metaMaskSDK.sdkInitPromise;
            const provider = this.getProvider();
            if (!provider) {
                return [];
            }
            /**
             * The eth_accounts method can hang on mobile devices when
             * the MetaMask SDK has not connected yet. So we use a retryable
             * to ensure the timeout will be respected
             */
            const accounts = yield retryableFn(() => provider.request({
                method: 'eth_accounts',
                params: [],
            }), {
                fallbackValue: [],
                timeoutMs: 1000,
            });
            if (!(accounts === null || accounts === void 0 ? void 0 : accounts.length)) {
                return [];
            }
            return accounts;
        });
    }
    signMessage(messageToSign, withAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.metaMaskSDK.sdkInitPromise;
            /**
             * Should wait for the window to be focused on mobile
             * to account for the user moving between the MetaMaskApp
             * and the browser
             */
            const windowFocusPromiseForMobile = !this.isInAppBrowser && isMobile()
                ? waitForFocusWindowEvent()
                : Promise.resolve();
            const provider = this.getProvider();
            if (!provider) {
                return undefined;
            }
            const [selectedAddress] = yield this.getConnectedAccounts();
            const effectiveAddress = withAddress !== null && withAddress !== void 0 ? withAddress : selectedAddress;
            if (!effectiveAddress) {
                return undefined;
            }
            const walletClient = this.getWalletClientForAddress(effectiveAddress);
            if (!walletClient)
                return undefined;
            const signature = yield walletClient.signMessage({
                message: messageToSign,
            });
            yield windowFocusPromiseForMobile;
            return signature;
        });
    }
    chooseAccountsToConnect() {
        return __awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    getWalletClient(chainId) {
        const provider = this.getProvider();
        if (!provider) {
            return undefined;
        }
        const selectedAddress = provider.getSelectedAddress();
        return this.getWalletClientForAddress(selectedAddress || undefined, chainId);
    }
    get rdns() {
        const { rdns } = this.metadata;
        if (!rdns) {
            throw new Error('rdns not found in metadata');
        }
        return rdns;
    }
    isInstalledOnBrowser() {
        var _a;
        const metaMaskEip6963Provider = (_a = this.ethProviderHelper) === null || _a === void 0 ? void 0 : _a.eip6963ProviderLookup(this.rdns);
        const isInstalled = Boolean(metaMaskEip6963Provider);
        return isInstalled;
    }
    setupEventListeners() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.metaMaskSDK.sdkInitPromise;
            const metaMaskProvider = this.getProvider();
            if (!metaMaskProvider) {
                return;
            }
            const { handleAccountChange, handleChainChange, handleDisconnect } = eventListenerHandlers(this);
            const handleAccountsChangedFromMetaMask = (accounts) => {
                /**
                 * MetaMask emits an account changed event when the wallet is disconnected
                 * so we ignore the accountsChanged event if the disconnect event was recent
                 */
                if (eventTimeline.isEventRecent('disconnect', 1000)) {
                    return;
                }
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                handleAccountChange(accounts);
            };
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            metaMaskProvider.on('accountsChanged', handleAccountsChangedFromMetaMask);
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            metaMaskProvider.on('chainChanged', handleChainChange);
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            metaMaskProvider.on('disconnect', handleDisconnect);
            this.teardownEventListeners = () => {
                metaMaskProvider.off('accountsChanged', handleAccountsChangedFromMetaMask);
                metaMaskProvider.off('chainChanged', handleChainChange);
                metaMaskProvider.off('disconnect', handleDisconnect);
            };
        });
    }
    /**
     * This override is necessary to wait for the MetaMask SDK to initialize
     * before calling the super method. Otherwise, the super method may fail
     * to fetch the provider
     */
    getNetwork() {
        const _super = Object.create(null, {
            getNetwork: { get: () => super.getNetwork }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield this.metaMaskSDK.sdkInitPromise;
            const net = yield _super.getNetwork.call(this);
            return net;
        });
    }
    // Utils
    getProvider() {
        var _a;
        return ((_a = this.metaMaskSDK.getProvider()) !== null && _a !== void 0 ? _a : this.metaMaskSDK.getMobileProvider());
    }
    evmNetworkByChainId(chainId) {
        return this.evmNetworks.find((network) => network.chainId === chainId);
    }
    getWalletClientForAddress(address, chainId) {
        var _a, _b;
        const provider = this.getProvider();
        if (!provider) {
            return undefined;
        }
        const effectiveChainId = (_b = (_a = this.toInt(chainId)) !== null && _a !== void 0 ? _a : this.getCurrentChainId()) !== null && _b !== void 0 ? _b : '1';
        const network = this.evmNetworkByChainId(effectiveChainId);
        return createWalletClient({
            account: address,
            chain: network ? getOrMapViemChain(network) : this.getActiveChain(),
            transport: custom(provider),
        });
    }
    toInt(chainId) {
        if (!chainId)
            return undefined;
        try {
            return parseInt(chainId);
        }
        catch (err) {
            logger.debug(err);
            return undefined;
        }
    }
    getCurrentChainId() {
        const provider = this.getProvider();
        if (!provider) {
            return undefined;
        }
        const chainId = provider.getChainId();
        if (isHex(chainId)) {
            return parseInt(chainId);
        }
        return chainId;
    }
    /**
     * Checks if the current environment is the MetaMask in-app browser
     * by checking if the MetaMask provider is installed in the window object
     * on a mobile device
     */
    getIsInAppBrowser() {
        var _a, _b;
        if (!isMobile())
            return false;
        const provider = ((_a = this.ethProviderHelper) === null || _a === void 0 ? void 0 : _a.eip6963ProviderLookup(this.rdns)) ||
            ((_b = this.ethProviderHelper) === null || _b === void 0 ? void 0 : _b.getInjectedProvider());
        return Boolean(provider);
    }
    shouldDeepLinkToMetaMaskInAppBrowser() {
        var _a;
        // Not in an in-app browser
        if (this.isInAppBrowser)
            return false;
        // Not a mobile device
        if (!isMobile())
            return false;
        // SDK is configured to use the in-app browser
        if (this.mobileExperience !== 'in-app-browser')
            return false;
        const isAppBrowserLinkPresent = ((_a = this.wallet) === null || _a === void 0 ? void 0 : _a.mobile) && this.wallet.mobile.inAppBrowser;
        // Wallet has an in-app browser link
        if (!isAppBrowserLinkPresent)
            return false;
        return true;
    }
    /**
     * Get wallet book wallet information
     */
    get wallet() {
        return findWalletBookWallet(this.walletBook, this.key);
    }
}
// Utils
const getReadonlyRPCMap = (evmNetworkRpcMap) => Object.keys(evmNetworkRpcMap).reduce((acc, chainId) => (Object.assign(Object.assign({}, acc), { [toHex(parseInt(chainId))]: evmNetworkRpcMap[chainId] })), {});
/**
 * Waits for the focus page event and await for an extra second
 * This is necessary to ensure the verify call will succeed
 */
const waitForFocusWindowEvent = () => new Promise((resolve) => {
    window.addEventListener('focus', resolve);
}).then(() => new Promise((resolve) => setTimeout(resolve, 1000)));

export { MetaMaskConnector };
