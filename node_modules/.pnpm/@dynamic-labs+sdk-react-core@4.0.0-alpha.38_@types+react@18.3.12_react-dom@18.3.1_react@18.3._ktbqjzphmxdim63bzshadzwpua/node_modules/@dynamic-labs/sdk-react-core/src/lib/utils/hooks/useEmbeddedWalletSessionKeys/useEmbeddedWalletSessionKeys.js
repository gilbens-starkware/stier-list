'use client'
import { __awaiter } from '../../../../../_virtual/_tslib.js';
import { useCallback } from 'react';
import { StorageService, InvalidEmbeddedWalletSessionKeyError } from '@dynamic-labs/utils';
import { EmbeddedWalletVersionEnum } from '@dynamic-labs/sdk-api-core';
import { logger } from '@dynamic-labs/wallet-connector-core';
import { SECURE_ENCLAVE_WALLET_SESSION_KEYS, SECURE_ENCLAVE_WALLET_SESSION_KEYS_STORAGE_OPTIONS } from '../../constants/localStorage.js';
import { p256Sign, p256Keygen } from '../useEmbeddedWallet/useSecureEnclaveEmbeddedWallet/utils.js';
import '../../../shared/logger.js';
import '@dynamic-labs/iconic';
import 'react/jsx-runtime';
import '../../../context/ViewContext/ViewContext.js';
import '@dynamic-labs/wallet-book';
import '../../constants/colors.js';
import '../../constants/values.js';
import '../../../store/state/loadingAndLifecycle.js';
import '../../../shared/consts/index.js';
import '../../../config/ApiEndpoint.js';
import '@dynamic-labs/multi-wallet';
import 'react-international-phone';
import '../../../store/state/projectSettings/projectSettings.js';
import { registerSessionKey } from '../../../data/api/embeddedWallets/embeddedWallets.js';
import { useUser } from '../../../store/state/user/user.js';
import '../../../locale/locale.js';
import { dynamicEvents } from '../../../events/dynamicEvents.js';

const useEmbeddedWalletSessionKeys = ({ environmentId, projectSettings, }) => {
    const { user } = useUser();
    // scenario 1: first time session register on first transaction.
    // Keys will have been previously generated at this point in local storage but marked as not registered
    // scenario 2: 2nd time register after expiration (key refresh)
    // scenario 3: refresh/rerender page - session still active
    // scenario 4: refresh/rerender page - session no longer active
    const registerEmbeddedWalletSessionKey = (...args_1) => __awaiter(void 0, [...args_1], void 0, function* ({ ignoreRestore = false, } = {}) {
        // check if session keys are already stored in session storage
        const sessionKeysSS = StorageService.getItem(SECURE_ENCLAVE_WALLET_SESSION_KEYS, SECURE_ENCLAVE_WALLET_SESSION_KEYS_STORAGE_OPTIONS);
        const decodedSessionKeys = sessionKeysSS
            ? JSON.parse(Buffer.from(sessionKeysSS, 'base64').toString())
            : undefined;
        if (!decodedSessionKeys) {
            logger.warn('Could not find session keys. Re-authentication is required to create new session keys.');
            dynamicEvents.emit('triggerLogout');
            throw new Error('Could not find session keys. Re-authentication is required to create new session keys.');
        }
        if (!user) {
            throw new Error('User not found');
        }
        if (decodedSessionKeys.expirationDate &&
            new Date() <= new Date(decodedSessionKeys.expirationDate) &&
            !ignoreRestore) {
            // scenario 3
            return decodedSessionKeys;
        }
        let publicKey;
        let privateKey;
        let privateKeyJwk;
        let prevSessionKeySignature = undefined;
        if (!decodedSessionKeys.registered) {
            // scenario 1
            ({ publicKey, privateKey, privateKeyJwk } = decodedSessionKeys);
        }
        else {
            // scenario 2 and 4
            const { publicKey: nextPublicKey, privateKey: nextPrivateKey, privateKeyJwk: nextPrivateKeyJwk, } = yield generateSessionKey();
            publicKey = nextPublicKey;
            privateKey = nextPrivateKey;
            privateKeyJwk = nextPrivateKeyJwk;
            prevSessionKeySignature = yield p256Sign(decodedSessionKeys.privateKeyJwk, user.sessionId);
        }
        let resp;
        try {
            resp = yield registerSessionKey({
                environmentId,
                prevSessionKeySignature,
                publicKey,
            });
        }
        catch (error) {
            if (error instanceof InvalidEmbeddedWalletSessionKeyError) {
                // this can happen if the public key passed during initial registration
                // does not match the root session public key that the backend expects
                logger.warn('Invalid embedded wallet session key. Re-authentication is required to create new session keys.');
                dynamicEvents.emit('triggerLogout');
            }
            throw error;
        }
        const expirationDate = new Date(resp.expiresAt * 1000);
        StorageService.setItem(SECURE_ENCLAVE_WALLET_SESSION_KEYS, toEncodedFormat(publicKey, privateKey, privateKeyJwk, true, expirationDate), SECURE_ENCLAVE_WALLET_SESSION_KEYS_STORAGE_OPTIONS);
        return { expirationDate, privateKey, publicKey };
    });
    const generateSessionKey = () => __awaiter(void 0, void 0, void 0, function* () {
        const { private: privateKey, public: publicKey, privateJwk, } = yield p256Keygen();
        // convert to base64 and store the session keys in session storage
        StorageService.setItem(SECURE_ENCLAVE_WALLET_SESSION_KEYS, toEncodedFormat(publicKey, privateKey, privateJwk, false), SECURE_ENCLAVE_WALLET_SESSION_KEYS_STORAGE_OPTIONS);
        return { privateKey, privateKeyJwk: privateJwk, publicKey };
    });
    const shouldRegisterSessionKeysOnSignin = () => {
        var _a;
        return ((_a = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.sdk.embeddedWallets) === null || _a === void 0 ? void 0 : _a.defaultWalletVersion) ===
            EmbeddedWalletVersionEnum.V2;
    };
    const toEncodedFormat = (publicKey, privateKey, privateKeyJwk, registered, expirationDate) => {
        const sessionKeys = {
            expirationDate,
            privateKey,
            privateKeyJwk,
            publicKey,
            registered,
        };
        const sessionKeysString = JSON.stringify(sessionKeys);
        return Buffer.from(sessionKeysString).toString('base64');
    };
    const removeSessionKey = useCallback(() => StorageService.removeItem(SECURE_ENCLAVE_WALLET_SESSION_KEYS, SECURE_ENCLAVE_WALLET_SESSION_KEYS_STORAGE_OPTIONS), []);
    return {
        generateSessionKey,
        registerEmbeddedWalletSessionKey,
        removeSessionKey,
        shouldRegisterSessionKeysOnSignin,
    };
};

export { useEmbeddedWalletSessionKeys };
