// src/hooks/use-account.ts
import { useCallback as useCallback2, useEffect as useEffect2, useState as useState2 } from "react";

// src/context/account.tsx
import React, { useContext } from "react";
import { jsx } from "react/jsx-runtime";
var AccountContext = React.createContext({
  account: void 0,
  address: void 0
});
function useStarknetAccount() {
  const { account, address } = useContext(AccountContext);
  return { account, address };
}

// src/context/starknet.tsx
import {
  mainnet,
  sepolia
} from "@starknet-react/chains";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import {
  createContext,
  useCallback,
  useContext as useContext2,
  useEffect,
  useRef,
  useState
} from "react";
import {
  constants
} from "starknet";
import { jsx as jsx2 } from "react/jsx-runtime";
var defaultQueryClient = new QueryClient();
var StarknetContext = createContext(void 0);
function useStarknet() {
  const state = useContext2(StarknetContext);
  if (!state) {
    throw new Error(
      "useStarknet must be used within a StarknetProvider or StarknetConfig"
    );
  }
  return state;
}

// src/utils.ts
import { validateAndParseAddress } from "starknet";
function getAddress(address) {
  return validateAndParseAddress(address);
}

// src/hooks/use-provider.ts
function useProvider() {
  const { provider } = useStarknet();
  return { provider };
}

// src/hooks/use-account.ts
function useAccount() {
  const { connector, chain } = useStarknet();
  const { provider } = useProvider();
  const { address: connectedAddress } = useStarknetAccount();
  const [state, setState] = useState2({
    status: "disconnected"
  });
  const refreshState = useCallback2(async () => {
    if (connector && provider && connectedAddress) {
      setState({
        status: "connected",
        connector,
        chainId: chain.id,
        account: void 0,
        address: getAddress(connectedAddress),
        isConnected: true,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: false
      });
      connector.account(provider).then(
        (connectedAccount) => setState((state2) => ({ ...state2, account: connectedAccount }))
      );
    } else {
      return setState({
        status: "disconnected",
        connector: void 0,
        chainId: void 0,
        account: void 0,
        address: void 0,
        isConnected: false,
        isConnecting: false,
        isDisconnected: true,
        isReconnecting: false
      });
    }
  }, [provider, connector, chain.id, connectedAddress]);
  useEffect2(() => {
    refreshState();
  }, [refreshState]);
  return state;
}

// src/hooks/use-wallet-request.ts
import { useCallback as useCallback3 } from "react";

// src/query.ts
import {
  useMutation as useMutation_,
  useQuery as useQuery_
} from "@tanstack/react-query";
function useQuery(args) {
  const base = useQuery_({ ...args, structuralSharing: false });
  return {
    data: base.data,
    error: base.error,
    status: base.status,
    isSuccess: base.isSuccess,
    isError: base.isError,
    isPending: base.isPending,
    fetchStatus: base.fetchStatus,
    isFetching: base.isFetching,
    isLoading: base.isLoading,
    refetch: base.refetch
  };
}
function useMutation(args) {
  const base = useMutation_(args);
  return {
    data: base.data,
    error: base.error,
    reset: base.reset,
    isError: base.isError,
    isIdle: base.isIdle,
    isPending: base.isPending,
    isSuccess: base.isSuccess,
    isPaused: base.isPaused,
    mutate: base.mutate,
    mutateAsync: base.mutateAsync,
    status: base.status,
    variables: base.variables
  };
}

// src/hooks/use-wallet-request.ts
function useWalletRequest(props) {
  const { connector } = useStarknet();
  const { type, params, ...rest } = props;
  const { mutate, mutateAsync, ...result } = useMutation({
    mutationKey: mutationKey({ type, params }),
    mutationFn: mutationFn({ connector }),
    ...rest
  });
  const request = useCallback3(
    (args) => mutate(args ?? { type, params }),
    [mutate, type, params]
  );
  const requestAsync = useCallback3(
    (args) => mutateAsync(args ?? { type, params }),
    [mutateAsync, type, params]
  );
  return {
    request,
    requestAsync,
    ...result
  };
}
function mutationKey({
  type,
  params
}) {
  return [{ entity: "walletRequest", type, params }];
}
function mutationFn({
  connector
}) {
  return async ({ type, params }) => {
    if (!connector) throw new Error("No connector connected");
    if (!type) throw new Error("Type is required");
    return await connector.request({ type, params });
  };
}

// src/hooks/use-add-chain.ts
function useAddChain(props) {
  const { params, ...rest } = props;
  const { request, requestAsync, ...result } = useWalletRequest({
    type: "wallet_addStarknetChain",
    params,
    ...rest
  });
  const addChain = (args) => {
    return request(
      args ? {
        params: args,
        type: "wallet_addStarknetChain"
      } : void 0
    );
  };
  const addChainAsync = (args) => {
    return requestAsync(
      args ? {
        params: args,
        type: "wallet_addStarknetChain"
      } : void 0
    );
  };
  return {
    addChain,
    addChainAsync,
    ...result
  };
}

// src/hooks/use-balance.ts
import { useMemo as useMemo2 } from "react";
import {
  BlockTag as BlockTag2,
  num,
  shortString
} from "starknet";
import { formatUnits } from "viem";

// src/hooks/use-contract.ts
import { useMemo } from "react";
import {
  Contract
} from "starknet";
function useContract({
  abi,
  address,
  provider: providedProvider
}) {
  const { provider: currentProvider } = useStarknet();
  const contract = useMemo(() => {
    const provider = providedProvider ? providedProvider : currentProvider;
    if (abi && address && provider) {
      return new Contract(abi, address, provider).typedv2(
        abi
      );
    }
    return void 0;
  }, [abi, address, providedProvider, currentProvider]);
  return { contract };
}

// src/hooks/use-invalidate-on-block.ts
import { useQueryClient } from "@tanstack/react-query";
import { useEffect as useEffect3, useState as useState3 } from "react";

// src/hooks/use-block-number.ts
import { BlockTag } from "starknet";
function useBlockNumber({
  blockIdentifier = BlockTag.LATEST,
  ...props
} = {}) {
  const { provider } = useStarknet();
  return useQuery({
    queryKey: queryKey({ blockIdentifier }),
    queryFn: queryFn({ provider, blockIdentifier }),
    ...props
  });
}
function queryKey({ blockIdentifier }) {
  return [{ entity: "blockNumber", blockIdentifier }];
}
function queryFn({
  provider,
  blockIdentifier
}) {
  return async () => {
    const block = await provider.getBlock(blockIdentifier);
    if (block.status !== "PENDING") {
      return block.block_number;
    }
    return void 0;
  };
}

// src/hooks/use-invalidate-on-block.ts
function useInvalidateOnBlock({
  enabled = true,
  queryKey: queryKey11
}) {
  const queryClient = useQueryClient();
  const [prevBlockNumber, setPrevBlockNumber] = useState3();
  const { data: blockNumber } = useBlockNumber({
    enabled
  });
  useEffect3(() => {
    if (!prevBlockNumber) {
      return setPrevBlockNumber(blockNumber);
    }
    if (blockNumber !== prevBlockNumber) {
      queryClient.invalidateQueries({ queryKey: queryKey11 }, { cancelRefetch: false });
      return setPrevBlockNumber(blockNumber);
    }
  }, [blockNumber, prevBlockNumber, queryKey11, queryClient]);
}

// src/hooks/use-network.ts
function useNetwork() {
  const { chain, chains } = useStarknet();
  return { chain, chains };
}

// src/hooks/use-balance.ts
var DEFAULT_FETCH_INTERVAL = 5e3;
function useBalance({
  token: token_,
  address,
  refetchInterval: refetchInterval_,
  watch = false,
  enabled: enabled_ = true,
  blockIdentifier = BlockTag2.LATEST,
  ...props
}) {
  const { chain } = useNetwork();
  const token = token_ ?? chain.nativeCurrency.address;
  const { contract } = useContract({
    abi: balanceABIFragment,
    address: token
  });
  const queryKey_ = useMemo2(
    () => queryKey2({ chain, token, address, blockIdentifier }),
    [chain, token, address, blockIdentifier]
  );
  const enabled = useMemo2(
    () => Boolean(enabled_ && contract && address),
    [enabled_, contract, address]
  );
  const refetchInterval = refetchInterval_ ?? (blockIdentifier === BlockTag2.PENDING && watch ? DEFAULT_FETCH_INTERVAL : void 0);
  useInvalidateOnBlock({
    enabled: Boolean(enabled && watch),
    queryKey: queryKey_
  });
  return useQuery({
    enabled,
    refetchInterval,
    queryKey: queryKey_,
    queryFn: queryFn2({ chain, contract, token, address, blockIdentifier }),
    ...props
  });
}
function queryKey2({
  chain,
  token,
  address,
  blockIdentifier
}) {
  return [
    {
      entity: "balance",
      chainId: chain?.name,
      token,
      address,
      blockIdentifier
    }
  ];
}
function queryFn2({
  chain,
  token,
  address,
  contract,
  blockIdentifier
}) {
  return async () => {
    if (!address) throw new Error("address is required");
    if (!contract) throw new Error("contract is required");
    const options = {
      blockIdentifier
    };
    const isNativeCurrency = token === chain.nativeCurrency.address;
    let symbol = chain.nativeCurrency.symbol;
    if (!isNativeCurrency) {
      const symbol_ = await contract.symbol(options);
      symbol = shortString.decodeShortString(num.toHex(symbol_));
    }
    let decimals = chain.nativeCurrency.decimals;
    if (!isNativeCurrency) {
      const decimals_ = await contract.decimals(options);
      decimals = Number(decimals_);
    }
    const balanceOf = await contract.balanceOf(address, options);
    const formatted = formatUnits(balanceOf, decimals);
    return {
      value: balanceOf,
      decimals,
      symbol,
      formatted
    };
  };
}
var balanceABIFragment = [
  {
    name: "core::integer::u256",
    type: "struct",
    members: [
      {
        name: "low",
        type: "core::integer::u128"
      },
      {
        name: "high",
        type: "core::integer::u128"
      }
    ]
  },
  {
    name: "balanceOf",
    type: "function",
    inputs: [
      {
        name: "account",
        type: "core::starknet::contract_address::ContractAddress"
      }
    ],
    outputs: [
      {
        type: "core::integer::u256"
      }
    ],
    state_mutability: "view"
  },
  {
    name: "symbol",
    type: "function",
    inputs: [],
    outputs: [
      {
        type: "core::felt252"
      }
    ],
    state_mutability: "view"
  },
  {
    name: "decimals",
    type: "function",
    inputs: [],
    outputs: [
      {
        type: "core::integer::u8"
      }
    ],
    state_mutability: "view"
  }
];

// src/hooks/use-block.ts
import {
  BlockTag as BlockTag3
} from "starknet";
function useBlock({
  blockIdentifier = BlockTag3.LATEST,
  ...props
} = {}) {
  const { provider } = useStarknet();
  return useQuery({
    queryKey: queryKey3({ blockIdentifier }),
    queryFn: queryFn3({ provider, blockIdentifier }),
    ...props
  });
}
function queryKey3({ blockIdentifier }) {
  return [{ entity: "block", blockIdentifier }];
}
function queryFn3({
  provider,
  blockIdentifier
}) {
  return async () => await provider.getBlock(blockIdentifier);
}

// src/hooks/use-call.ts
import { useMemo as useMemo3 } from "react";
import {
  BlockTag as BlockTag4
} from "starknet";
var DEFAULT_FETCH_INTERVAL2 = 5e3;
function useCall({
  abi,
  address,
  functionName,
  args,
  blockIdentifier = BlockTag4.LATEST,
  refetchInterval: refetchInterval_,
  watch = false,
  enabled: enabled_ = true,
  parseArgs,
  parseResult,
  ...props
}) {
  const { chain } = useNetwork();
  const { contract } = useContract({ abi, address });
  const queryKey_ = useMemo3(
    () => queryKey4({
      chain,
      contract,
      functionName,
      args,
      blockIdentifier
    }),
    [chain, contract, functionName, args, blockIdentifier]
  );
  const enabled = useMemo3(
    () => Boolean(enabled_ && contract && functionName && args),
    [enabled_, contract, functionName, args]
  );
  const refetchInterval = refetchInterval_ ?? (blockIdentifier === BlockTag4.PENDING && watch ? DEFAULT_FETCH_INTERVAL2 : void 0);
  useInvalidateOnBlock({
    enabled: Boolean(enabled && watch),
    queryKey: queryKey_
  });
  return useQuery({
    queryKey: queryKey_,
    queryFn: queryFn4({
      contract,
      functionName,
      args,
      blockIdentifier,
      parseArgs,
      parseResult
    }),
    refetchInterval,
    enabled,
    ...props
  });
}
function queryKey4({
  chain,
  contract,
  functionName,
  args,
  blockIdentifier
}) {
  return [
    {
      entity: "readContract",
      chainId: chain?.name,
      contract: contract?.address,
      functionName,
      args,
      blockIdentifier
    }
  ];
}
function queryFn4({
  contract,
  functionName,
  args,
  blockIdentifier,
  parseArgs = true,
  parseResult = true
}) {
  return async () => {
    if (!contract) throw new Error("contract is required");
    if (contract.functions[functionName] === void 0) {
      throw new Error(`function ${functionName} not found in contract`);
    }
    return contract.call(functionName, args, {
      parseRequest: parseArgs,
      parseResponse: parseResult,
      blockIdentifier
    });
  };
}

// src/hooks/use-connect.ts
import { useCallback as useCallback4 } from "react";
function useConnect(props = {}) {
  const { connector, connectors, connect: connect_, chain } = useStarknet();
  const { mutate, mutateAsync, variables, ...result } = useMutation({
    mutationKey: [{ entity: "connect", chainId: chain.name }],
    mutationFn: connect_,
    ...props
  });
  const connect = useCallback4(
    (args) => mutate(args ?? { connector }),
    [mutate, connector]
  );
  const connectAsync = useCallback4(
    (args) => mutateAsync(args ?? { connector }),
    [mutateAsync, connector]
  );
  return {
    connector,
    connectors,
    pendingConnector: variables?.connector,
    connect,
    connectAsync,
    variables,
    ...result
  };
}

// src/hooks/use-contract-factory.ts
import { useMemo as useMemo4 } from "react";
import { ContractFactory } from "starknet";
function useContractFactory({
  compiledContract,
  classHash,
  abi
}) {
  const { account } = useAccount();
  const contractFactory = useMemo4(() => {
    if (compiledContract && account && classHash) {
      return new ContractFactory({
        compiledContract,
        classHash,
        account,
        abi
      });
    }
    return void 0;
  }, [compiledContract, classHash, account, abi]);
  return { contractFactory };
}

// src/hooks/use-declare-contract.ts
function useDeclareContract(props) {
  const { params, ...rest } = props;
  const { request, requestAsync, ...result } = useWalletRequest({
    type: "wallet_addDeclareTransaction",
    params,
    ...rest
  });
  const declare = (args) => {
    return request(
      args ? {
        params: args,
        type: "wallet_addDeclareTransaction"
      } : void 0
    );
  };
  const declareAsync = (args) => {
    return requestAsync(
      args ? {
        params: args,
        type: "wallet_addDeclareTransaction"
      } : void 0
    );
  };
  return {
    declare,
    declareAsync,
    ...result
  };
}

// src/hooks/use-deploy-account.ts
function useDeployAccount({
  classHash,
  constructorCalldata,
  addressSalt,
  contractAddress,
  options,
  ...props
}) {
  const { account } = useAccount();
  const { mutate, mutateAsync, ...result } = useMutation({
    mutationKey: mutationKey2({
      account,
      classHash,
      constructorCalldata,
      addressSalt,
      contractAddress,
      options
    }),
    mutationFn: mutationFn2({
      account,
      classHash,
      constructorCalldata,
      addressSalt,
      contractAddress,
      options
    }),
    ...props
  });
  return {
    deployAccount: mutate,
    deployAccountAsync: mutateAsync,
    ...result
  };
}
function mutationKey2(props) {
  return [{ entity: "deployAccount", ...props }];
}
function mutationFn2({
  account,
  classHash,
  constructorCalldata,
  addressSalt,
  contractAddress,
  options
}) {
  return async () => {
    if (!account) throw new Error("account is required");
    if (!classHash) throw new Error("classHash is required");
    return await account.deployAccount(
      { classHash, constructorCalldata, addressSalt, contractAddress },
      options
    );
  };
}

// src/hooks/use-disconnect.ts
function useDisconnect(props = {}) {
  const { disconnect, chain } = useStarknet();
  const { mutate, mutateAsync, ...result } = useMutation({
    mutationKey: [{ entity: "disconnect", chainId: chain.name }],
    mutationFn: disconnect,
    ...props
  });
  return {
    disconnect: mutate,
    disconnectAsync: mutateAsync,
    ...result
  };
}

// src/hooks/use-estimate-fees.ts
import { useMemo as useMemo5 } from "react";
function useEstimateFees({
  calls,
  options,
  watch = false,
  enabled: enabled_ = true,
  ...props
}) {
  const { account } = useAccount();
  const queryKey_ = useMemo5(
    () => queryKey5({ calls, options }),
    [calls, options]
  );
  const enabled = useMemo5(() => Boolean(enabled_ && calls), [enabled_, calls]);
  useInvalidateOnBlock({
    enabled: Boolean(enabled && watch),
    queryKey: queryKey_
  });
  return useQuery({
    queryKey: queryKey_,
    queryFn: queryFn5({
      account,
      calls,
      options
    }),
    enabled,
    ...props
  });
}
function queryKey5({ calls, options }) {
  return [
    {
      entity: "estimateInvokeFee",
      calls,
      options
    }
  ];
}
function queryFn5({
  account,
  calls,
  options
}) {
  return async () => {
    if (!account) throw new Error("account is required");
    if (!calls || calls.length === 0) throw new Error("calls are required");
    return account?.estimateInvokeFee(calls, options);
  };
}

// src/hooks/use-explorer.ts
function useExplorer() {
  const { explorer, chain } = useStarknet();
  if (!explorer)
    throw Error("Explorer is undefined. Try adding it to StarknetConfig.");
  const explorerInstance = explorer(chain);
  if (!explorerInstance) throw Error("Explorer Instance is undefined");
  return explorerInstance;
}

// src/hooks/use-nonce-for-address.ts
import {
  BlockTag as BlockTag5
} from "starknet";
function useNonceForAddress({
  address,
  blockIdentifier = BlockTag5.LATEST,
  ...props
}) {
  const { provider } = useStarknet();
  return useQuery({
    queryKey: queryKey6({ address, blockIdentifier }),
    queryFn: queryFn6({ address, provider, blockIdentifier }),
    ...props
  });
}
function queryKey6({
  address,
  blockIdentifier
}) {
  return [{ entity: "nonce", blockIdentifier, address }];
}
function queryFn6({
  provider,
  blockIdentifier,
  address
}) {
  return async () => {
    const nonce = await provider.getNonceForAddress(address, blockIdentifier);
    return nonce;
  };
}

// src/hooks/use-read-contract.ts
function useReadContract(props) {
  return useCall(props);
}

// src/hooks/use-send-transaction.ts
function useSendTransaction(props) {
  const { calls, ...rest } = props;
  const params = calls ? { calls: transformCalls(calls) } : void 0;
  const { request, requestAsync, ...result } = useWalletRequest({
    type: "wallet_addInvokeTransaction",
    params,
    ...rest
  });
  const send = (args) => {
    return request(
      args ? {
        params: { calls: transformCalls(args) },
        type: "wallet_addInvokeTransaction"
      } : void 0
    );
  };
  const sendAsync = (args) => {
    return requestAsync(
      args ? {
        params: { calls: transformCalls(args) },
        type: "wallet_addInvokeTransaction"
      } : void 0
    );
  };
  return {
    send,
    sendAsync,
    ...result
  };
}
function transformCalls(calls) {
  return calls.map(
    (call) => ({
      contract_address: call.contractAddress,
      entry_point: call.entrypoint,
      calldata: call.calldata
    })
  );
}

// src/hooks/use-sign.ts
function useSignTypedData(props) {
  const { params, ...rest } = props;
  const { request, requestAsync, ...result } = useWalletRequest({
    type: "wallet_signTypedData",
    params,
    ...rest
  });
  const signTypedData = (args) => {
    return request(
      args ? {
        params: args,
        type: "wallet_signTypedData"
      } : void 0
    );
  };
  const signTypedDataAsync = (args) => {
    return requestAsync(
      args ? {
        params: args,
        type: "wallet_signTypedData"
      } : void 0
    );
  };
  return {
    signTypedData,
    signTypedDataAsync,
    ...result
  };
}

// src/hooks/use-stark-address.ts
import { useMemo as useMemo6 } from "react";
import {
  CallData,
  Provider,
  starknetId
} from "starknet";
function useStarkAddress({
  name,
  contract,
  enabled: enabled_ = true,
  ...props
}) {
  const { provider } = useProvider();
  const { chain } = useNetwork();
  const enabled = useMemo6(() => Boolean(enabled_ && name), [enabled_, name]);
  return useQuery({
    queryKey: queryKey7({ name, contract, network: chain.network }),
    queryFn: queryFn7({ name, contract, provider, network: chain.network }),
    enabled,
    ...props
  });
}
function queryKey7({
  name,
  contract,
  network
}) {
  return [{ entity: "addressFromStarkName", name, contract, network }];
}
function queryFn7({
  name,
  contract,
  provider,
  network
}) {
  return async () => {
    if (!name) throw new Error("name is required");
    const namingContract = contract ?? StarknetIdNamingContract[network];
    const p = new Provider(provider);
    const encodedDomain = encodeDomain(name);
    const result = await p.callContract({
      contractAddress: namingContract,
      entrypoint: "domain_to_address",
      calldata: CallData.compile({ domain: encodedDomain, hint: [] })
    });
    if (BigInt(result[0]) === BigInt(0)) throw new Error("Address not found");
    return result[0];
  };
}
var StarknetIdNamingContract = {
  sepolia: "0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474",
  mainnet: "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678"
};
var encodeDomain = (domain) => {
  if (!domain) return ["0"];
  const encoded = [];
  for (const subdomain of domain.replace(".stark", "").split("."))
    encoded.push(starknetId.useEncoded(subdomain).toString(10));
  return encoded;
};

// src/hooks/use-stark-name.ts
import { useMemo as useMemo7 } from "react";
import {
  Provider as Provider2
} from "starknet";
function useStarkName({
  address,
  contract,
  enabled: enabled_ = true,
  ...props
}) {
  const { provider } = useProvider();
  const { chain } = useNetwork();
  const enabled = useMemo7(
    () => Boolean(enabled_ && address),
    [enabled_, address]
  );
  return useQuery({
    queryKey: queryKey8({ address, contract, network: chain.network }),
    queryFn: queryFn8({ address, contract, provider, network: chain.network }),
    enabled,
    ...props
  });
}
function queryKey8({
  address,
  contract,
  network
}) {
  return [{ entity: "starkName", address, contract, network }];
}
function queryFn8({
  address,
  contract,
  provider,
  network
}) {
  return async () => {
    if (!address) throw new Error("address is required");
    const namingContract = contract ?? StarknetIdNamingContract2[network];
    const p = new Provider2(provider);
    return await p.getStarkName(address, namingContract);
  };
}
var StarknetIdNamingContract2 = {
  sepolia: "0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474",
  mainnet: "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678"
};

// src/hooks/use-stark-profile.ts
import { useMemo as useMemo8 } from "react";
function useStarkProfile({
  address,
  useDefaultPfp = true,
  namingContract,
  identityContract,
  enabled: enabled_ = true,
  ...props
}) {
  const { provider } = useProvider();
  const { chain } = useNetwork();
  if (!StarknetIdcontracts[chain.network])
    throw new Error("Network not supported");
  const { contract: multicallContract } = useContract({
    abi: multicallABI,
    address: StarknetIdcontracts[chain.network]["multicall"]
  });
  const enabled = useMemo8(
    () => Boolean(enabled_ && address),
    [enabled_, address]
  );
  const { refetchInterval, ...rest } = props;
  return useQuery({
    queryKey: queryKey9({
      address,
      namingContract,
      identityContract,
      network: chain.network,
      useDefaultPfp
    }),
    queryFn: queryFn9({
      address,
      useDefaultPfp,
      namingContract,
      provider,
      network: chain.network,
      identityContract,
      multicallContract
    }),
    enabled,
    refetchInterval,
    ...rest
  });
}
function queryKey9({
  address,
  namingContract,
  identityContract,
  network,
  useDefaultPfp
}) {
  return [
    {
      entity: "starkprofile",
      address,
      namingContract,
      identityContract,
      network,
      useDefaultPfp
    }
  ];
}
function queryFn9({
  address,
  useDefaultPfp,
  namingContract,
  identityContract,
  provider,
  network,
  multicallContract
}) {
  return async () => {
    throw new Error("Not implemented");
  };
}
var StarknetIdcontracts = {
  sepolia: {
    naming: "0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474",
    identity: "0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda",
    verifier: "0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566",
    verifier_pop: "0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a",
    verifier_pfp: "0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02",
    multicall: "0x07a9013697371ce40d0306b4c810c6a4db9bfda119dd9ae1e8701c8e288d734b"
  },
  mainnet: {
    naming: "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678",
    identity: "0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af",
    verifier: "0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf",
    verifier_pop: "0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4",
    verifier_pfp: "0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7",
    multicall: "0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970"
  }
};
var multicallABI = [
  {
    name: "ComposableMulticallImpl",
    type: "impl",
    interface_name: "composable_multicall::IComposableMulticall"
  },
  {
    name: "composable_multicall::Execution",
    type: "enum",
    variants: [
      {
        name: "Static",
        type: "()"
      },
      {
        name: "IfEqual",
        type: "(core::integer::u32, core::integer::u32, core::felt252)"
      },
      {
        name: "IfNotEqual",
        type: "(core::integer::u32, core::integer::u32, core::felt252)"
      }
    ]
  },
  {
    name: "composable_multicall::DynamicFelt",
    type: "enum",
    variants: [
      {
        name: "Hardcoded",
        type: "core::felt252"
      },
      {
        name: "Reference",
        type: "(core::integer::u32, core::integer::u32)"
      }
    ]
  },
  {
    name: "composable_multicall::DynamicCalldata",
    type: "enum",
    variants: [
      {
        name: "Hardcoded",
        type: "core::felt252"
      },
      {
        name: "Reference",
        type: "(core::integer::u32, core::integer::u32)"
      },
      {
        name: "ArrayReference",
        type: "(core::integer::u32, core::integer::u32)"
      }
    ]
  },
  {
    name: "composable_multicall::DynamicCall",
    type: "struct",
    members: [
      {
        name: "execution",
        type: "composable_multicall::Execution"
      },
      {
        name: "to",
        type: "composable_multicall::DynamicFelt"
      },
      {
        name: "selector",
        type: "composable_multicall::DynamicFelt"
      },
      {
        name: "calldata",
        type: "core::array::Array::<composable_multicall::DynamicCalldata>"
      }
    ]
  },
  {
    name: "core::array::Span::<core::felt252>",
    type: "struct",
    members: [
      {
        name: "snapshot",
        type: "@core::array::Array::<core::felt252>"
      }
    ]
  },
  {
    name: "composable_multicall::IComposableMulticall",
    type: "interface",
    items: [
      {
        name: "aggregate",
        type: "function",
        inputs: [
          {
            name: "calls",
            type: "core::array::Array::<composable_multicall::DynamicCall>"
          }
        ],
        outputs: [
          {
            type: "core::array::Array::<core::array::Span::<core::felt252>>"
          }
        ],
        state_mutability: "view"
      }
    ]
  },
  {
    kind: "enum",
    name: "composable_multicall::contract::ComposableMulticall::Event",
    type: "event",
    variants: []
  }
];

// src/hooks/use-switch-chain.ts
function useSwitchChain(props) {
  const { params, ...rest } = props;
  const { request, requestAsync, ...result } = useWalletRequest({
    type: "wallet_switchStarknetChain",
    params,
    ...rest
  });
  const switchChain = (args) => {
    return request(
      args ? {
        params: args,
        type: "wallet_switchStarknetChain"
      } : void 0
    );
  };
  const switchChainAsync = (args) => {
    return requestAsync(
      args ? {
        params: args,
        type: "wallet_switchStarknetChain"
      } : void 0
    );
  };
  return {
    switchChain,
    switchChainAsync,
    ...result
  };
}

// src/hooks/use-transaction-receipt.ts
import { useMemo as useMemo9 } from "react";
function useTransactionReceipt({
  hash,
  watch,
  enabled: enabled_ = true,
  ...props
}) {
  const { provider, chain } = useStarknet();
  const queryKey_ = useMemo9(() => queryKey10({ chain, hash }), [chain, hash]);
  const enabled = useMemo9(() => Boolean(enabled_ && hash), [enabled_, hash]);
  useInvalidateOnBlock({
    enabled: Boolean(enabled && watch),
    queryKey: queryKey_
  });
  return useQuery({
    queryKey: queryKey_,
    queryFn: queryFn10({ provider, hash }),
    enabled,
    ...props
  });
}
function queryKey10({ chain, hash }) {
  return [
    { entity: "transactionReceipt", chainId: chain?.name, hash }
  ];
}
function queryFn10({
  provider,
  hash
}) {
  return async () => {
    if (!hash) throw new Error("hash is required");
    return await provider.getTransactionReceipt(hash);
  };
}

// src/hooks/use-watch-asset.ts
function useWatchAsset(props) {
  const { params, ...rest } = props;
  const { request, requestAsync, ...result } = useWalletRequest({
    type: "wallet_watchAsset",
    params,
    ...rest
  });
  const watchAsset = (args) => {
    return request(
      args ? {
        params: args,
        type: "wallet_watchAsset"
      } : void 0
    );
  };
  const watchAssetAsync = (args) => {
    return requestAsync(
      args ? {
        params: args,
        type: "wallet_watchAsset"
      } : void 0
    );
  };
  return {
    watchAsset,
    watchAssetAsync,
    ...result
  };
}
export {
  useAccount,
  useAddChain,
  useBalance,
  useBlock,
  useBlockNumber,
  useCall,
  useConnect,
  useContract,
  useContractFactory,
  useDeclareContract,
  useDeployAccount,
  useDisconnect,
  useEstimateFees,
  useExplorer,
  useInvalidateOnBlock,
  useNetwork,
  useNonceForAddress,
  useProvider,
  useReadContract,
  useSendTransaction,
  useSignTypedData,
  useStarkAddress,
  useStarkName,
  useStarkProfile,
  useSwitchChain,
  useTransactionReceipt,
  useWalletRequest,
  useWatchAsset
};
//# sourceMappingURL=index.js.map