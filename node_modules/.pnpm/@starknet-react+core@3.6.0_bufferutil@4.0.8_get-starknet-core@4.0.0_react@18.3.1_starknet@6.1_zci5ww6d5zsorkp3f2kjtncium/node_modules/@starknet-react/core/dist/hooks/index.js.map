{"version":3,"sources":["../../src/hooks/use-account.ts","../../src/context/account.tsx","../../src/context/starknet.tsx","../../src/utils.ts","../../src/hooks/use-provider.ts","../../src/hooks/use-wallet-request.ts","../../src/query.ts","../../src/hooks/use-add-chain.ts","../../src/hooks/use-balance.ts","../../src/hooks/use-contract.ts","../../src/hooks/use-invalidate-on-block.ts","../../src/hooks/use-block-number.ts","../../src/hooks/use-network.ts","../../src/hooks/use-block.ts","../../src/hooks/use-call.ts","../../src/hooks/use-connect.ts","../../src/hooks/use-contract-factory.ts","../../src/hooks/use-declare-contract.ts","../../src/hooks/use-deploy-account.ts","../../src/hooks/use-disconnect.ts","../../src/hooks/use-estimate-fees.ts","../../src/hooks/use-explorer.ts","../../src/hooks/use-nonce-for-address.ts","../../src/hooks/use-read-contract.ts","../../src/hooks/use-send-transaction.ts","../../src/hooks/use-sign.ts","../../src/hooks/use-stark-address.ts","../../src/hooks/use-stark-name.ts","../../src/hooks/use-stark-profile.ts","../../src/hooks/use-switch-chain.ts","../../src/hooks/use-transaction-receipt.ts","../../src/hooks/use-watch-asset.ts"],"sourcesContent":["import { Permission } from \"@starknet-io/types-js\";\nimport type { Address } from \"@starknet-react/chains\";\nimport { useCallback, useEffect, useState } from \"react\";\nimport type { AccountInterface } from \"starknet\";\nimport type { Connector } from \"../connectors\";\nimport { useStarknetAccount } from \"../context/account\";\nimport { useStarknet } from \"../context/starknet\";\nimport { getAddress } from \"../utils\";\nimport { useConnect } from \"./use-connect\";\nimport { useProvider } from \"./use-provider\";\n\n/** Account connection status. */\nexport type AccountStatus =\n  | \"connected\"\n  | \"disconnected\"\n  | \"connecting\"\n  | \"reconnecting\";\n\n/** Value returned from `useAccount`. */\nexport type UseAccountResult = {\n  /** The connected account object. */\n  account?: AccountInterface;\n  /** The address of the connected account. */\n  address?: Address;\n  /** The connected connector. */\n  connector?: Connector;\n  /** Connector's chain id */\n  chainId?: bigint;\n  /** True if connecting. */\n  isConnecting?: boolean;\n  /** True if reconnecting. */\n  isReconnecting?: boolean;\n  /** True if connected. */\n  isConnected?: boolean;\n  /** True if disconnected. */\n  isDisconnected?: boolean;\n  /** The connection status. */\n  status: AccountStatus;\n};\n\n/**\n * Hook for accessing the account and its connection status.\n *\n * @remarks\n *\n * This hook is used to access the `AccountInterface` object provided by the\n * currently connected wallet.\n */\nexport function useAccount(): UseAccountResult {\n  const { connector, chain } = useStarknet();\n  const { provider } = useProvider();\n  const { address: connectedAddress } = useStarknetAccount();\n  const [state, setState] = useState<UseAccountResult>({\n    status: \"disconnected\",\n  });\n\n  const refreshState = useCallback(async () => {\n    if (connector && provider && connectedAddress) {\n      setState({\n        status: \"connected\" as const,\n        connector,\n        chainId: chain.id,\n        account: undefined,\n        address: getAddress(connectedAddress),\n        isConnected: true,\n        isConnecting: false,\n        isDisconnected: false,\n        isReconnecting: false,\n      });\n\n      // Lazily build the account since it makes a wallet call to check if the wallet is locked.\n      connector\n        .account(provider)\n        .then((connectedAccount) =>\n          setState((state) => ({ ...state, account: connectedAccount })),\n        );\n    } else {\n      return setState({\n        status: \"disconnected\" as const,\n        connector: undefined,\n        chainId: undefined,\n        account: undefined,\n        address: undefined,\n        isConnected: false,\n        isConnecting: false,\n        isDisconnected: true,\n        isReconnecting: false,\n      });\n    }\n  }, [provider, connector, chain.id, connectedAddress]);\n\n  useEffect(() => {\n    refreshState();\n  }, [refreshState]);\n\n  return state;\n}\n","import type { Address } from \"@starknet-react/chains\";\nimport React, { useContext } from \"react\";\n\nimport type { AccountInterface } from \"starknet\";\n\nconst AccountContext = React.createContext<{\n  account: AccountInterface | undefined;\n  address: Address | undefined;\n}>({\n  account: undefined,\n  address: undefined,\n});\n\nexport function useStarknetAccount() {\n  const { account, address } = useContext(AccountContext);\n  return { account, address };\n}\n\nexport function AccountProvider({\n  address,\n  account,\n  children,\n}: {\n  address?: Address;\n  account?: AccountInterface;\n  children: React.ReactNode;\n}) {\n  return (\n    <AccountContext.Provider value={{ account, address }}>\n      {children}\n    </AccountContext.Provider>\n  );\n}\n","import {\n  type Address,\n  type Chain,\n  mainnet,\n  sepolia,\n} from \"@starknet-react/chains\";\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\nimport type React from \"react\";\nimport {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport {\n  constants,\n  type AccountInterface,\n  type ProviderInterface,\n} from \"starknet\";\n\nimport type { Connector } from \"../connectors\";\nimport type { ConnectorData } from \"../connectors/base\";\nimport { ConnectorNotFoundError } from \"../errors\";\nimport type { ExplorerFactory } from \"../explorers/\";\nimport type { ChainProviderFactory } from \"../providers\";\n\nimport { AccountProvider } from \"./account\";\n\nconst defaultQueryClient = new QueryClient();\n\n/** State of the Starknet context. */\nexport interface StarknetState {\n  /** Connected connector. */\n  connector?: Connector;\n  /** Connect the given connector. */\n  connect: ({ connector }: { connector?: Connector }) => Promise<void>;\n  /** Disconnect the currently connected connector. */\n  disconnect: () => Promise<void>;\n  /** List of registered connectors. */\n  connectors: Connector[];\n  /** Current explorer factory. */\n  explorer?: ExplorerFactory;\n  /** Chains supported by the app. */\n  chains: Chain[];\n  /** Current chain. */\n  chain: Chain;\n  /** Current provider. */\n  provider: ProviderInterface;\n  /** Error. */\n  error?: Error;\n}\n\nconst StarknetContext = createContext<StarknetState | undefined>(undefined);\n\n/**\n * Returns the current Starknet context state.\n *\n * @remarks\n *\n * This hook should be used sparingly and will be deprecated.\n *\n * Use the following hooks:\n *\n *  - `account`: `useAccount`\n *  - `connect`, `disconnect`, `connectors`: `useConnectors`\n *\n * @example\n * This example shows how to access the Starknet provider.\n * ```tsx\n * function Component() {\n *   const { library } = useStarknet()\n *\n *   if (!library.provider) return <span>Account URL: {library.baseUrl}</span>\n *   return <span>Provider URL: {library.provider.baseUrl}</span>\n * }\n * ```\n */\nexport function useStarknet(): StarknetState {\n  const state = useContext(StarknetContext);\n  if (!state) {\n    throw new Error(\n      \"useStarknet must be used within a StarknetProvider or StarknetConfig\",\n    );\n  }\n  return state;\n}\n\ninterface StarknetManagerState {\n  currentChain: Chain;\n  connectors: Connector[];\n  currentAddress?: Address;\n  currentProvider: ProviderInterface;\n  error?: Error;\n}\n\ninterface UseStarknetManagerProps {\n  chains: Chain[];\n  provider: ChainProviderFactory;\n  explorer?: ExplorerFactory;\n  connectors?: Connector[];\n  autoConnect?: boolean;\n  defaultChainId?: bigint;\n}\n\nfunction useStarknetManager({\n  chains,\n  provider,\n  explorer,\n  connectors = [],\n  autoConnect = false,\n  defaultChainId,\n}: UseStarknetManagerProps): StarknetState & {\n  account?: AccountInterface;\n  address?: Address;\n} {\n  const defaultChain = defaultChainId\n    ? (chains.find((c) => c.id === defaultChainId) ?? chains[0])\n    : chains[0];\n  if (defaultChain === undefined) {\n    throw new Error(\"Must provide at least one chain.\");\n  }\n\n  const { chain: _, provider: defaultProvider } = providerForChain(\n    defaultChain,\n    provider,\n  );\n\n  // The currently connected connector needs to be accessible from the\n  // event handler.\n  const connectorRef = useRef<Connector | undefined>();\n  const [state, setState] = useState<StarknetManagerState>({\n    currentChain: defaultChain,\n    currentProvider: defaultProvider,\n    connectors,\n  });\n\n  const updateChainAndProvider = useCallback(\n    ({ chainId }: { chainId?: bigint }) => {\n      if (!chainId) return;\n      for (const chain of chains) {\n        if (chain.id === chainId) {\n          const { chain: newChain, provider: newProvider } = providerForChain(\n            chain,\n            provider,\n          );\n          setState((state) => ({\n            ...state,\n            currentChain: newChain,\n            currentProvider: newProvider,\n          }));\n          return;\n        }\n      }\n    },\n    [chains, provider],\n  );\n\n  const handleConnectorChange = useCallback(\n    async ({ chainId, account: address }: ConnectorData) => {\n      if (chainId) {\n        updateChainAndProvider({ chainId });\n      }\n\n      if (address && connectorRef.current) {\n        setState((state) => ({\n          ...state,\n          currentAddress: address as Address,\n        }));\n      }\n    },\n    [updateChainAndProvider],\n  );\n\n  useEffect(() => {\n    if (!connectorRef.current) {\n      // Only update currentChain if no wallet is connected\n      setState((state) => ({\n        ...state,\n        currentChain: defaultChain,\n        currentProvider: providerForChain(defaultChain, provider).provider,\n      }));\n    }\n  }, [defaultChain, provider]);\n  const connect = useCallback(\n    async ({ connector }: { connector?: Connector }) => {\n      if (!connector) {\n        throw new Error(\"Must provide a connector.\");\n      }\n\n      const needsListenerSetup = connectorRef.current?.id !== connector.id;\n      if (needsListenerSetup) {\n        connectorRef.current?.off(\"change\", handleConnectorChange);\n        connectorRef.current?.off(\"disconnect\", disconnect);\n      }\n\n      try {\n        const { chainId, account: address } = await connector.connect({\n          chainIdHint: defaultChain.id,\n        });\n\n        if (address !== state.currentAddress) {\n          connectorRef.current = connector;\n\n          setState((state) => ({\n            ...state,\n            currentAddress: address as Address,\n          }));\n        }\n\n        if (autoConnect) {\n          localStorage.setItem(\"lastUsedConnector\", connector.id);\n        }\n\n        if (needsListenerSetup) {\n          connector.on(\"change\", handleConnectorChange);\n          connector.on(\"disconnect\", disconnect);\n        }\n\n        updateChainAndProvider({ chainId });\n      } catch (err) {\n        setState((state) => ({\n          ...state,\n          error: new ConnectorNotFoundError(),\n        }));\n        throw err;\n      }\n    },\n    [\n      autoConnect,\n      state.currentAddress,\n      defaultChain.id,\n      handleConnectorChange,\n      updateChainAndProvider,\n    ],\n  );\n\n  const disconnect = useCallback(async () => {\n    setState((state) => ({\n      ...state,\n      currentAddress: undefined,\n      currentProvider: defaultProvider,\n      currentChain: defaultChain,\n    }));\n\n    if (autoConnect) {\n      localStorage.removeItem(\"lastUsedConnector\");\n    }\n\n    if (!connectorRef.current) return;\n    connectorRef.current.off(\"change\", handleConnectorChange);\n    connectorRef.current.off(\"disconnect\", disconnect);\n\n    try {\n      await connectorRef.current.disconnect();\n    } catch {}\n    connectorRef.current = undefined;\n  }, [autoConnect, handleConnectorChange, defaultProvider, defaultChain]);\n\n  // Dependencies intentionally omitted since we only want\n  // this executed once.\n  // biome-ignore lint/correctness/useExhaustiveDependencies: want to execute only once\n  useEffect(() => {\n    async function tryAutoConnect(connectors: Connector[]) {\n      const lastConnectedConnectorId =\n        localStorage.getItem(\"lastUsedConnector\");\n      if (lastConnectedConnectorId === null) {\n        return;\n      }\n\n      const lastConnectedConnector = connectors.find(\n        (connector) => connector.id === lastConnectedConnectorId,\n      );\n      if (lastConnectedConnector === undefined) {\n        return;\n      }\n\n      try {\n        if (!(await lastConnectedConnector.ready())) {\n          // Not authorized anymore.\n          return;\n        }\n\n        connect({ connector: lastConnectedConnector });\n      } catch {\n        // no-op\n      }\n    }\n\n    if (autoConnect && !connectorRef.current) {\n      tryAutoConnect(connectors);\n    }\n  }, []);\n\n  return {\n    address: state.currentAddress,\n    provider: state.currentProvider,\n    chain: state.currentChain,\n    connector: connectorRef.current,\n    explorer,\n    connect,\n    disconnect,\n    connectors,\n    chains,\n  };\n}\n\n/** Arguments for `StarknetProvider`. */\nexport interface StarknetProviderProps {\n  /** Chains supported by the app. */\n  chains: Chain[];\n  /** Provider to use. */\n  provider: ChainProviderFactory;\n  /** List of connectors to use. */\n  connectors?: Connector[];\n  /** Explorer to use. */\n  explorer?: ExplorerFactory;\n  /** Connect the first available connector on page load. */\n  autoConnect?: boolean;\n  /** React-query client to use. */\n  queryClient?: QueryClient;\n  /** Application. */\n  children?: React.ReactNode;\n  /** Default chain to use when wallet is not connected */\n  defaultChainId?: bigint;\n}\n\n/** Root Starknet context provider. */\nexport function StarknetProvider({\n  chains,\n  provider,\n  connectors,\n  explorer,\n  autoConnect,\n  queryClient,\n  defaultChainId,\n  children,\n}: StarknetProviderProps): JSX.Element {\n  const { account, address, ...state } = useStarknetManager({\n    chains,\n    provider,\n    explorer,\n    connectors,\n    autoConnect,\n    defaultChainId,\n  });\n\n  return (\n    <QueryClientProvider client={queryClient ?? defaultQueryClient}>\n      <StarknetContext.Provider value={state}>\n        <AccountProvider address={address} account={account}>\n          {children}\n        </AccountProvider>\n      </StarknetContext.Provider>\n    </QueryClientProvider>\n  );\n}\n\nfunction providerForChain(\n  chain: Chain,\n  factory: ChainProviderFactory,\n): { chain: Chain; provider: ProviderInterface } {\n  const provider = factory(chain);\n  if (provider) {\n    return { chain, provider };\n  }\n\n  throw new Error(`No provider found for chain ${chain.name}`);\n}\n\nexport function starknetChainId(\n  chainId: bigint,\n): constants.StarknetChainId | undefined {\n  switch (chainId) {\n    case mainnet.id:\n      return constants.StarknetChainId.SN_MAIN;\n    case sepolia.id:\n      return constants.StarknetChainId.SN_SEPOLIA;\n    default:\n      return undefined;\n  }\n}\n","import type { Address } from \"@starknet-react/chains\";\nimport { validateAndParseAddress } from \"starknet\";\n\n/**\n * Validate and format the address.\n *\n * @param address - The address string to validate.\n * @returns The validated and formatted address as Address type.\n */\nexport function getAddress(address: string): Address {\n  return validateAndParseAddress(address) as Address;\n}\n","import type { ProviderInterface } from \"starknet\";\n\nimport { useStarknet } from \"../context/starknet\";\n\n/** Value returned from `useProvider`. */\nexport interface UseProviderResult {\n  /** The current provider. */\n  provider: ProviderInterface;\n}\n\n/**\n * Hook for accessing the current provider.\n *\n * @remarks\n *\n * Use this hook to access the current provider object\n * implementing starknet.js `ProviderInterface`.\n */\nexport function useProvider(): UseProviderResult {\n  const { provider } = useStarknet();\n  return { provider };\n}\n","import type { RpcMessage, RpcTypeToMessageMap } from \"@starknet-io/types-js\";\nimport { useCallback } from \"react\";\n\nimport type { Connector } from \"../connectors/base\";\nimport { useStarknet } from \"../context/starknet\";\nimport {\n  type UseMutationProps,\n  type UseMutationResult,\n  useMutation,\n} from \"../query\";\n\n/** Message types for connector request call. */\nexport type RequestMessageTypes = RpcMessage[\"type\"];\n\n/** Result type of request call. */\nexport type RequestResult<T extends RequestMessageTypes> =\n  RpcTypeToMessageMap[T][\"result\"];\n\n/** Args type of request call. */\nexport type RequestArgs<T extends RequestMessageTypes> = Partial<{\n  type: T;\n  params: RpcTypeToMessageMap[T][\"params\"];\n}>;\n\ntype MutationResult<T extends RequestMessageTypes> = UseMutationResult<\n  RpcTypeToMessageMap[T][\"result\"],\n  Error,\n  RequestArgs<T>\n>;\n\n/** Arguments for `useWalletRequest` hook. */\nexport type UseWalletRequestProps<T extends RequestMessageTypes> =\n  RequestArgs<T> & UseMutationProps<RequestResult<T>, Error, RequestArgs<T>>;\n\n/** Value returned from `useWalletRequest`. */\nexport type UseWalletRequestResult<T extends RequestMessageTypes> = Omit<\n  MutationResult<T>,\n  \"mutate\" | \"mutateAsync\"\n> & {\n  request: (args?: RequestArgs<T>) => void;\n  requestAsync: (args?: RequestArgs<T>) => Promise<RequestResult<T>>;\n};\n\n/** Hook to perform request calls to connected wallet */\nexport function useWalletRequest<T extends RequestMessageTypes>(\n  props: UseWalletRequestProps<T>,\n): UseWalletRequestResult<T> {\n  const { connector } = useStarknet();\n\n  const { type, params, ...rest } = props;\n\n  const { mutate, mutateAsync, ...result } = useMutation({\n    mutationKey: mutationKey({ type, params }),\n    mutationFn: mutationFn({ connector }),\n    ...rest,\n  });\n\n  const request = useCallback(\n    (args?: RequestArgs<T>) => mutate(args ?? { type, params }),\n    [mutate, type, params],\n  );\n\n  const requestAsync = useCallback(\n    (args?: RequestArgs<T>) => mutateAsync(args ?? { type, params }),\n    [mutateAsync, type, params],\n  );\n\n  return {\n    request,\n    requestAsync,\n    ...result,\n  };\n}\n\nfunction mutationKey<T extends RequestMessageTypes>({\n  type,\n  params,\n}: RequestArgs<T>) {\n  return [{ entity: \"walletRequest\", type, params }] as const;\n}\n\nfunction mutationFn<T extends RequestMessageTypes>({\n  connector,\n}: {\n  connector?: Connector;\n}) {\n  return async ({ type, params }: RequestArgs<T>) => {\n    if (!connector) throw new Error(\"No connector connected\");\n    if (!type) throw new Error(\"Type is required\");\n    return await connector.request({ type, params });\n  };\n}\n","import {\n  type QueryKey,\n  type UseMutationOptions as UseMutationOptions_,\n  type UseMutationResult as UseMutationResult_,\n  type UseQueryOptions as UseQueryOptions_,\n  type UseQueryResult as UseQueryResult_,\n  useMutation as useMutation_,\n  useQuery as useQuery_,\n} from \"@tanstack/react-query\";\n\nexport type UseQueryProps<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Pick<\n  UseQueryOptions_<TQueryFnData, TError, TData, TQueryKey>,\n  \"enabled\" | \"refetchInterval\" | \"retry\" | \"retryDelay\"\n>;\n\nexport type UseQueryResult<TData, TError> = Pick<\n  UseQueryResult_<TData, TError>,\n  | \"data\"\n  | \"error\"\n  | \"status\"\n  | \"isSuccess\"\n  | \"isError\"\n  | \"isPending\"\n  | \"fetchStatus\"\n  | \"isFetching\"\n  | \"isLoading\"\n  | \"refetch\"\n>;\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  args: UseQueryOptions_<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError> {\n  const base = useQuery_({ ...args, structuralSharing: false });\n\n  return {\n    data: base.data,\n    error: base.error,\n    status: base.status,\n    isSuccess: base.isSuccess,\n    isError: base.isError,\n    isPending: base.isPending,\n    fetchStatus: base.fetchStatus,\n    isFetching: base.isFetching,\n    isLoading: base.isLoading,\n    refetch: base.refetch,\n  };\n}\nexport type UseMutationProps<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> = Pick<\n  UseMutationOptions_<TData, TError, TVariables, TContext>,\n  \"onSuccess\" | \"onError\" | \"onMutate\" | \"onSettled\"\n>;\n\nexport type UseMutationResult<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> = Pick<\n  UseMutationResult_<TData, TError, TVariables, TContext>,\n  | \"data\"\n  | \"error\"\n  | \"isError\"\n  | \"isIdle\"\n  | \"isPending\"\n  | \"isPaused\"\n  | \"isSuccess\"\n  | \"reset\"\n  | \"mutate\"\n  | \"mutateAsync\"\n  | \"status\"\n  | \"variables\"\n>;\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = unknown,\n  TContext = unknown,\n>(\n  args: UseMutationOptions_<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const base = useMutation_(args);\n\n  return {\n    data: base.data,\n    error: base.error,\n    reset: base.reset,\n    isError: base.isError,\n    isIdle: base.isIdle,\n    isPending: base.isPending,\n    isSuccess: base.isSuccess,\n    isPaused: base.isPaused,\n    mutate: base.mutate,\n    mutateAsync: base.mutateAsync,\n    status: base.status,\n    variables: base.variables,\n  };\n}\n","import type { AddStarknetChainParameters } from \"@starknet-io/types-js\";\n\nimport {\n  type RequestArgs,\n  type RequestResult,\n  type UseWalletRequestProps,\n  type UseWalletRequestResult,\n  useWalletRequest,\n} from \"./use-wallet-request\";\n\nexport type UseAddChainArgs = AddStarknetChainParameters;\n\nexport type UseAddChainProps = Omit<\n  UseWalletRequestProps<\"wallet_addStarknetChain\">,\n  keyof RequestArgs<\"wallet_addStarknetChain\">\n> & {\n  params?: UseAddChainArgs;\n};\n\nexport type UseAddChainResult = Omit<\n  UseWalletRequestResult<\"wallet_addStarknetChain\">,\n  \"request\" | \"requestAsync\"\n> & {\n  addChain: (args?: UseAddChainArgs) => void;\n  addChainAsync: (\n    args?: UseAddChainArgs,\n  ) => Promise<RequestResult<\"wallet_addStarknetChain\">>;\n};\n\n/**\n * Hook to add a new network in the list of networks of the wallet.\n */\nexport function useAddChain(props: UseAddChainProps): UseAddChainResult {\n  const { params, ...rest } = props;\n\n  const { request, requestAsync, ...result } = useWalletRequest({\n    type: \"wallet_addStarknetChain\",\n    params,\n    ...rest,\n  });\n\n  const addChain = (args?: UseAddChainArgs) => {\n    return request(\n      args\n        ? {\n            params: args,\n            type: \"wallet_addStarknetChain\",\n          }\n        : undefined,\n    );\n  };\n\n  const addChainAsync = (args?: UseAddChainArgs) => {\n    return requestAsync(\n      args\n        ? {\n            params: args,\n            type: \"wallet_addStarknetChain\",\n          }\n        : undefined,\n    );\n  };\n\n  return {\n    addChain,\n    addChainAsync,\n    ...result,\n  };\n}\n","import type { Address, Chain } from \"@starknet-react/chains\";\nimport { useMemo } from \"react\";\nimport {\n  type BlockNumber,\n  BlockTag,\n  type CallOptions,\n  num,\n  shortString,\n} from \"starknet\";\nimport { formatUnits } from \"viem\";\n\nimport { type UseQueryProps, type UseQueryResult, useQuery } from \"../query\";\n\nimport { type StarknetTypedContract, useContract } from \"./use-contract\";\nimport { useInvalidateOnBlock } from \"./use-invalidate-on-block\";\nimport { useNetwork } from \"./use-network\";\n\nconst DEFAULT_FETCH_INTERVAL = 5_000;\n\nexport type Balance = {\n  decimals: number;\n  symbol: string;\n  formatted: string;\n  value: bigint;\n};\n\nexport type UseBalanceProps = UseQueryProps<\n  Balance,\n  Error,\n  Balance,\n  ReturnType<typeof queryKey>\n> & {\n  /** The contract's address. Defaults to the native currency. */\n  token?: Address;\n  /** The address to fetch balance for. */\n  address?: Address;\n  /** Whether to watch for changes. */\n  watch?: boolean;\n  /** Block identifier used when performing call. */\n  blockIdentifier?: BlockNumber;\n};\n\nexport type UseBalanceResult = UseQueryResult<Balance, Error>;\n\ntype TAbi = typeof balanceABIFragment;\ntype Contract = StarknetTypedContract<TAbi>;\n\n/**\n * Fetch the balance for the provided address and token.\n *\n * If no token is provided, the native currency is used.\n */\nexport function useBalance({\n  token: token_,\n  address,\n  refetchInterval: refetchInterval_,\n  watch = false,\n  enabled: enabled_ = true,\n  blockIdentifier = BlockTag.LATEST,\n  ...props\n}: UseBalanceProps) {\n  const { chain } = useNetwork();\n  const token = token_ ?? chain.nativeCurrency.address;\n\n  const { contract } = useContract({\n    abi: balanceABIFragment,\n    address: token,\n  });\n\n  const queryKey_ = useMemo(\n    () => queryKey({ chain, token, address, blockIdentifier }),\n    [chain, token, address, blockIdentifier],\n  );\n\n  const enabled = useMemo(\n    () => Boolean(enabled_ && contract && address),\n    [enabled_, contract, address],\n  );\n\n  const refetchInterval =\n    refetchInterval_ ??\n    (blockIdentifier === BlockTag.PENDING && watch\n      ? DEFAULT_FETCH_INTERVAL\n      : undefined);\n\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_,\n  });\n\n  return useQuery({\n    enabled,\n    refetchInterval,\n    queryKey: queryKey_,\n    queryFn: queryFn({ chain, contract, token, address, blockIdentifier }),\n    ...props,\n  });\n}\n\nfunction queryKey({\n  chain,\n  token,\n  address,\n  blockIdentifier,\n}: {\n  chain: Chain;\n  token?: string;\n  address?: string;\n  blockIdentifier?: BlockNumber;\n}) {\n  return [\n    {\n      entity: \"balance\",\n      chainId: chain?.name,\n      token,\n      address,\n      blockIdentifier,\n    },\n  ] as const;\n}\n\nfunction queryFn({\n  chain,\n  token,\n  address,\n  contract,\n  blockIdentifier,\n}: {\n  chain: Chain;\n  token?: string;\n  address?: string;\n  contract?: Contract;\n  blockIdentifier?: BlockNumber;\n}) {\n  return async () => {\n    if (!address) throw new Error(\"address is required\");\n    if (!contract) throw new Error(\"contract is required\");\n\n    const options: CallOptions = {\n      blockIdentifier,\n    };\n\n    const isNativeCurrency = token === chain.nativeCurrency.address;\n\n    let symbol = chain.nativeCurrency.symbol;\n    if (!isNativeCurrency) {\n      const symbol_ = await contract.symbol(options);\n      symbol = shortString.decodeShortString(num.toHex(symbol_));\n    }\n\n    let decimals = chain.nativeCurrency.decimals;\n    if (!isNativeCurrency) {\n      const decimals_ = await contract.decimals(options);\n      decimals = Number(decimals_);\n    }\n\n    const balanceOf = (await contract.balanceOf(address, options)) as bigint;\n\n    const formatted = formatUnits(balanceOf, decimals);\n\n    return {\n      value: balanceOf,\n      decimals: decimals,\n      symbol: symbol,\n      formatted: formatted,\n    };\n  };\n}\n\nconst balanceABIFragment = [\n  {\n    name: \"core::integer::u256\",\n    type: \"struct\",\n    members: [\n      {\n        name: \"low\",\n        type: \"core::integer::u128\",\n      },\n      {\n        name: \"high\",\n        type: \"core::integer::u128\",\n      },\n    ],\n  },\n  {\n    name: \"balanceOf\",\n    type: \"function\",\n    inputs: [\n      {\n        name: \"account\",\n        type: \"core::starknet::contract_address::ContractAddress\",\n      },\n    ],\n    outputs: [\n      {\n        type: \"core::integer::u256\",\n      },\n    ],\n    state_mutability: \"view\",\n  },\n  {\n    name: \"symbol\",\n    type: \"function\",\n    inputs: [],\n    outputs: [\n      {\n        type: \"core::felt252\",\n      },\n    ],\n    state_mutability: \"view\",\n  },\n  {\n    name: \"decimals\",\n    type: \"function\",\n    inputs: [],\n    outputs: [\n      {\n        type: \"core::integer::u8\",\n      },\n    ],\n    state_mutability: \"view\",\n  },\n] as const;\n","import type { Address } from \"@starknet-react/chains\";\nimport type { Abi } from \"abi-wan-kanabi\";\nimport type {\n  ContractFunctions,\n  ContractFunctionsPopulateTransaction,\n  ExtractAbiFunction,\n  ExtractAbiFunctionNames,\n  ExtractArgs,\n  FunctionRet,\n} from \"abi-wan-kanabi/dist/kanabi\";\nimport { useMemo } from \"react\";\nimport {\n  type Call,\n  type CallOptions,\n  Contract,\n  type ProviderInterface,\n} from \"starknet\";\n\nimport { useStarknet } from \"../context/starknet\";\n\n// did this because \"Omit\" wont work directly over an abstract class\ntype Contract_ = {\n  [K in keyof Contract as K extends \"populate\" | \"populateTransaction\" | \"call\"\n    ? never\n    : K]: Contract[K];\n};\n\ntype ArgsArray_<\n  TAbi extends Abi,\n  TFunctionName extends ExtractAbiFunctionNames<TAbi>,\n> = ExtractArgs<TAbi, ExtractAbiFunction<TAbi, TFunctionName>>;\n\n// with reference to 'abi-wan-kanabi' but with args accepting only array type\ntype TypedContractActions_<TAbi extends Abi> = {\n  call<TFunctionName extends ExtractAbiFunctionNames<TAbi>>(\n    method: TFunctionName,\n    args?: ArgsArray_<TAbi, TFunctionName>,\n    options?: CallOptions,\n  ): Promise<FunctionRet<TAbi, TFunctionName>>;\n  populate<TFunctionName extends ExtractAbiFunctionNames<TAbi>>(\n    method: TFunctionName,\n    args?: ArgsArray_<TAbi, TFunctionName>,\n  ): Call;\n  populateTransaction: ContractFunctionsPopulateTransaction<TAbi>;\n};\n\ntype TypedContract_<TAbi extends Abi> = TypedContractActions_<TAbi> &\n  ContractFunctions<TAbi>;\n\nexport type StarknetTypedContract<TAbi extends Abi> = TypedContract_<TAbi> &\n  Contract_;\n\n/** Arguments for `useContract`. */\nexport interface UseContractArgs<TAbi extends Abi> {\n  /** The contract abi\n   * @remarks\n   *\n   * You must pass ABI as a const\n   *\n   * @example\n   * abi: [\n   *   {\n   *     type: \"function\",\n   *     name: \"fn_simple_array\",\n   *     inputs: [\n   *       {\n   *         name: \"arg\",\n   *         type: \"core::array::Array::<core::integer::u8>\",\n   *       },\n   *     ],\n   *     outputs: [],\n   *     state_mutability: \"view\",\n   *   }\n   *  ] as const\n   *\n   */\n  abi?: TAbi;\n  /** The contract address. */\n  address?: Address;\n  /** The provider, by default it will be the current one. */\n  provider?: ProviderInterface | null;\n}\n\n/** Value returned from `useContract`. */\nexport interface UseContractResult<TAbi extends Abi> {\n  /** The contract. */\n  contract?: StarknetTypedContract<TAbi>;\n}\n\n/**\n * Hook to bind a `Contract` instance.\n *\n * @remarks\n *\n * - The returned contract is a starknet.js `Contract` object.\n * - Must pass `abi` as const for strict type safety\n *\n */\nexport function useContract<TAbi extends Abi>({\n  abi,\n  address,\n  provider: providedProvider,\n}: UseContractArgs<TAbi>): UseContractResult<TAbi> {\n  const { provider: currentProvider } = useStarknet();\n\n  const contract = useMemo(() => {\n    const provider = providedProvider ? providedProvider : currentProvider;\n    if (abi && address && provider) {\n      return new Contract(abi, address, provider).typedv2(\n        abi,\n      ) as StarknetTypedContract<TAbi>;\n    }\n    return undefined;\n  }, [abi, address, providedProvider, currentProvider]);\n\n  return { contract };\n}\n","import { type QueryKey, useQueryClient } from \"@tanstack/react-query\";\nimport { useEffect, useState } from \"react\";\n\nimport { useBlockNumber } from \"./use-block-number\";\n\n/**\n * Invalidate the given query on every new block.\n */\nexport function useInvalidateOnBlock({\n  enabled = true,\n  queryKey,\n}: {\n  enabled?: boolean;\n  queryKey: QueryKey;\n}) {\n  const queryClient = useQueryClient();\n\n  const [prevBlockNumber, setPrevBlockNumber] = useState<number | undefined>();\n\n  const { data: blockNumber } = useBlockNumber({\n    enabled,\n  });\n\n  useEffect(() => {\n    if (!prevBlockNumber) {\n      return setPrevBlockNumber(blockNumber);\n    }\n\n    if (blockNumber !== prevBlockNumber) {\n      queryClient.invalidateQueries({ queryKey }, { cancelRefetch: false });\n      return setPrevBlockNumber(blockNumber);\n    }\n  }, [blockNumber, prevBlockNumber, queryKey, queryClient]);\n}\n","import { type BlockNumber, BlockTag, type ProviderInterface } from \"starknet\";\n\nimport { useStarknet } from \"../context/starknet\";\nimport { type UseQueryProps, type UseQueryResult, useQuery } from \"../query\";\n\n/** Arguments for `useBlockNumber`. */\nexport type UseBlockNumberProps = UseQueryProps<\n  number | undefined,\n  Error,\n  number,\n  ReturnType<typeof queryKey>\n> & {\n  /** Identifier for the block to fetch. */\n  blockIdentifier?: BlockNumber;\n};\n\n/** Value returned from `useBlockNumber`. */\nexport type UseBlockNumberResult = UseQueryResult<number | undefined, Error>;\n\n/**\n * Hook for fetching the current block number.\n *\n * @remarks\n *\n * Control if and how often data is refreshed with `refetchInterval`.\n */\nexport function useBlockNumber({\n  blockIdentifier = BlockTag.LATEST,\n  ...props\n}: UseBlockNumberProps = {}): UseBlockNumberResult {\n  const { provider } = useStarknet();\n\n  return useQuery({\n    queryKey: queryKey({ blockIdentifier }),\n    queryFn: queryFn({ provider, blockIdentifier }),\n    ...props,\n  });\n}\n\nfunction queryKey({ blockIdentifier }: { blockIdentifier: BlockNumber }) {\n  return [{ entity: \"blockNumber\", blockIdentifier }] as const;\n}\n\nfunction queryFn({\n  provider,\n  blockIdentifier,\n}: {\n  provider: ProviderInterface;\n  blockIdentifier: BlockNumber;\n}) {\n  return async () => {\n    const block = await provider.getBlock(blockIdentifier);\n    if (block.status !== \"PENDING\") {\n      return block.block_number;\n    }\n    return undefined;\n  };\n}\n","import type { Chain } from \"@starknet-react/chains\";\n\nimport { useStarknet } from \"../context/starknet\";\n\n/** Value returned from `useNetwork`. */\nexport type UseNetworkResult = {\n  /** The current chain. */\n  chain: Chain;\n  /** List of supported chains. */\n  chains: Chain[];\n};\n\n/**\n * Hook for accessing the current connected chain.\n *\n * @remarks\n *\n * The network object contains information about the\n * network.\n *\n */\nexport function useNetwork(): UseNetworkResult {\n  const { chain, chains } = useStarknet();\n  return { chain, chains };\n}\n","import {\n  type BlockNumber,\n  BlockTag,\n  type GetBlockResponse,\n  type ProviderInterface,\n} from \"starknet\";\n\nimport { useStarknet } from \"../context/starknet\";\nimport { type UseQueryProps, type UseQueryResult, useQuery } from \"../query\";\n\n/** Arguments for `useBlock`. */\nexport type UseBlockProps = UseQueryProps<\n  GetBlockResponse,\n  Error,\n  GetBlockResponse,\n  ReturnType<typeof queryKey>\n> & {\n  /** Identifier for the block to fetch. */\n  blockIdentifier?: BlockNumber;\n};\n\n/** Value returned from `useBlock`. */\nexport type UseBlockResult = UseQueryResult<GetBlockResponse, Error>;\n\n/**\n * Hook for fetching a block.\n *\n * @remarks\n *\n * Specify which block to fetch with the `blockIdentifier` argument.\n * Control if and how often data is refreshed with `refetchInterval`.\n */\nexport function useBlock({\n  blockIdentifier = BlockTag.LATEST,\n  ...props\n}: UseBlockProps = {}): UseBlockResult {\n  const { provider } = useStarknet();\n  return useQuery({\n    queryKey: queryKey({ blockIdentifier }),\n    queryFn: queryFn({ provider, blockIdentifier }),\n    ...props,\n  });\n}\n\nfunction queryKey({ blockIdentifier }: { blockIdentifier: BlockNumber }) {\n  return [{ entity: \"block\", blockIdentifier }] as const;\n}\n\nfunction queryFn({\n  provider,\n  blockIdentifier,\n}: {\n  provider: ProviderInterface;\n  blockIdentifier: BlockNumber;\n}) {\n  return async () => await provider.getBlock(blockIdentifier);\n}\n","import type { Address, Chain } from \"@starknet-react/chains\";\nimport { useMemo } from \"react\";\nimport {\n  type Abi,\n  type ArgsOrCalldata,\n  type BlockNumber,\n  BlockTag,\n  type Contract,\n  type Result,\n} from \"starknet\";\n\nimport { type UseQueryProps, type UseQueryResult, useQuery } from \"../query\";\nimport { useContract } from \"./use-contract\";\nimport { useInvalidateOnBlock } from \"./use-invalidate-on-block\";\nimport { useNetwork } from \"./use-network\";\n\nconst DEFAULT_FETCH_INTERVAL = 5_000;\n\ntype CallArgs = {\n  /** The contract's function name. */\n  functionName: string;\n  /** Read arguments. */\n  args?: ArgsOrCalldata;\n  /** Block identifier used when performing call. */\n  blockIdentifier?: BlockNumber;\n  /** Parse arguments before passing to contract. @default true */\n  parseArgs?: boolean;\n  /** Parse result after calling contract. @default true */\n  parseResult?: boolean;\n};\n\nexport type CallQueryKey = typeof queryKey;\n\n/** Options for `useCall`. */\nexport type UseCallProps = CallArgs &\n  UseQueryProps<Result, Error, Result, ReturnType<CallQueryKey>> & {\n    /** The target contract's ABI. */\n    abi?: Abi;\n    /** The target contract's address. */\n    address?: Address;\n    /** Refresh data at every block. */\n    watch?: boolean;\n  };\n\n/** Value returned from `useCall`. */\nexport type UseCallResult = UseQueryResult<Result, Error>;\n\n/**\n * Hook to perform a read-only contract call.\n *\n * @remarks\n *\n * The hook only performs a call if the target `abi`, `address`,\n * `functionName`, and `args` are not undefined.\n *\n */\nexport function useCall({\n  abi,\n  address,\n  functionName,\n  args,\n  blockIdentifier = BlockTag.LATEST,\n  refetchInterval: refetchInterval_,\n  watch = false,\n  enabled: enabled_ = true,\n  parseArgs,\n  parseResult,\n  ...props\n}: UseCallProps): UseCallResult {\n  const { chain } = useNetwork();\n  const { contract } = useContract({ abi, address });\n\n  const queryKey_ = useMemo(\n    () =>\n      queryKey({\n        chain,\n        contract: contract as Contract,\n        functionName,\n        args,\n        blockIdentifier,\n      }),\n    [chain, contract, functionName, args, blockIdentifier],\n  );\n\n  const enabled = useMemo(\n    () => Boolean(enabled_ && contract && functionName && args),\n    [enabled_, contract, functionName, args],\n  );\n\n  const refetchInterval =\n    refetchInterval_ ??\n    (blockIdentifier === BlockTag.PENDING && watch\n      ? DEFAULT_FETCH_INTERVAL\n      : undefined);\n\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_,\n  });\n\n  return useQuery({\n    queryKey: queryKey_,\n    queryFn: queryFn({\n      contract: contract as Contract,\n      functionName,\n      args,\n      blockIdentifier,\n      parseArgs,\n      parseResult,\n    }),\n    refetchInterval,\n    enabled,\n    ...props,\n  });\n}\n\nfunction queryKey({\n  chain,\n  contract,\n  functionName,\n  args,\n  blockIdentifier,\n}: { chain?: Chain; contract?: Contract } & CallArgs) {\n  return [\n    {\n      entity: \"readContract\",\n      chainId: chain?.name,\n      contract: contract?.address,\n      functionName,\n      args,\n      blockIdentifier,\n    },\n  ] as const;\n}\n\nfunction queryFn({\n  contract,\n  functionName,\n  args,\n  blockIdentifier,\n  parseArgs = true,\n  parseResult = true,\n}: { contract?: Contract } & CallArgs) {\n  return async () => {\n    if (!contract) throw new Error(\"contract is required\");\n    if (contract.functions[functionName] === undefined) {\n      throw new Error(`function ${functionName} not found in contract`);\n    }\n\n    return contract.call(functionName, args, {\n      parseRequest: parseArgs,\n      parseResponse: parseResult,\n      blockIdentifier,\n    });\n  };\n}\n","import { useCallback } from \"react\";\n\nimport type { Connector } from \"../connectors/base\";\nimport { useStarknet } from \"../context/starknet\";\nimport {\n  type UseMutationProps,\n  type UseMutationResult,\n  useMutation,\n} from \"../query\";\n\nexport type ConnectVariables = { connector?: Connector };\n\ntype MutationResult = UseMutationResult<void, Error, ConnectVariables>;\n\nexport type UseConnectProps = UseMutationProps<void, Error, ConnectVariables>;\n\n/** Value returned from `useConnect`. */\nexport type UseConnectResult = Omit<\n  MutationResult,\n  \"mutate\" | \"mutateAsync\"\n> & {\n  /** Current connector. */\n  connector?: Connector;\n  /** Connectors available for the current chain. */\n  connectors: Connector[];\n  /** Connector waiting approval for connection. */\n  pendingConnector?: Connector;\n  /** Connect to a new connector. */\n  connect: (args?: ConnectVariables) => void;\n  /** Connect to a new connector. */\n  connectAsync: (args?: ConnectVariables) => Promise<void>;\n};\n\n/**\n * Hook for connecting to a StarkNet wallet.\n *\n * @remarks\n *\n * Use this to implement a \"connect wallet\" component.\n *\n * ```\n */\nexport function useConnect(props: UseConnectProps = {}): UseConnectResult {\n  const { connector, connectors, connect: connect_, chain } = useStarknet();\n\n  const { mutate, mutateAsync, variables, ...result } = useMutation({\n    mutationKey: [{ entity: \"connect\", chainId: chain.name }],\n    mutationFn: connect_,\n    ...props,\n  });\n\n  const connect = useCallback(\n    (args?: ConnectVariables) => mutate(args ?? { connector }),\n    [mutate, connector],\n  );\n\n  const connectAsync = useCallback(\n    (args?: ConnectVariables) => mutateAsync(args ?? { connector }),\n    [mutateAsync, connector],\n  );\n\n  return {\n    connector,\n    connectors,\n    pendingConnector: variables?.connector,\n    connect,\n    connectAsync,\n    variables,\n    ...result,\n  };\n}\n","import { useMemo } from \"react\";\nimport { type Abi, type CompiledContract, ContractFactory } from \"starknet\";\n\nimport { useAccount } from \"./use-account\";\n\n/** Arguments for `useContractFactory`. */\nexport interface UseContractFactoryProps {\n  /** The compiled contract. */\n  compiledContract?: CompiledContract;\n  /** The class hash  */\n  classHash: string;\n  /** The contract abi. */\n  abi?: Abi;\n}\n\n/** Value returned from `useContractFactory`. */\nexport interface UseContractFactoryResult {\n  /** The contract factory. */\n  contractFactory?: ContractFactory;\n}\n\n/**\n * Hook to create a `ContractFactory`.\n *\n * @remarks\n *\n * The returned contract factory is a starknet.js `ContractFactory` object.\n *\n * This hook works well with `useDeploy`.\n */\nexport function useContractFactory({\n  compiledContract,\n  classHash,\n  abi,\n}: UseContractFactoryProps): UseContractFactoryResult {\n  const { account } = useAccount();\n\n  const contractFactory = useMemo(() => {\n    if (compiledContract && account && classHash) {\n      return new ContractFactory({\n        compiledContract,\n        classHash,\n        account,\n        abi,\n      });\n    }\n    return undefined;\n  }, [compiledContract, classHash, account, abi]);\n\n  return { contractFactory };\n}\n","import type { AddDeclareTransactionParameters } from \"@starknet-io/types-js\";\n\nimport {\n  type RequestArgs,\n  type RequestResult,\n  type UseWalletRequestProps,\n  type UseWalletRequestResult,\n  useWalletRequest,\n} from \"./use-wallet-request\";\n\nexport type UseDeclareContractArgs = AddDeclareTransactionParameters;\n\nexport type UseDeclareContractProps = Omit<\n  UseWalletRequestProps<\"wallet_addDeclareTransaction\">,\n  keyof RequestArgs<\"wallet_addDeclareTransaction\">\n> & {\n  params?: UseDeclareContractArgs;\n};\n\nexport type UseDeclareContractResult = Omit<\n  UseWalletRequestResult<\"wallet_addDeclareTransaction\">,\n  \"request\" | \"requestAsync\"\n> & {\n  declare: (args?: UseDeclareContractArgs) => void;\n  declareAsync: (\n    args?: UseDeclareContractArgs,\n  ) => Promise<RequestResult<\"wallet_addDeclareTransaction\">>;\n};\n\n/**\n * Hook to declare a new class in the current network.\n *\n */\nexport function useDeclareContract(\n  props: UseDeclareContractProps,\n): UseDeclareContractResult {\n  const { params, ...rest } = props;\n\n  const { request, requestAsync, ...result } = useWalletRequest({\n    type: \"wallet_addDeclareTransaction\",\n    params,\n    ...rest,\n  });\n\n  const declare = (args?: UseDeclareContractArgs) => {\n    return request(\n      args\n        ? {\n            params: args,\n            type: \"wallet_addDeclareTransaction\",\n          }\n        : undefined,\n    );\n  };\n\n  const declareAsync = (args?: UseDeclareContractArgs) => {\n    return requestAsync(\n      args\n        ? {\n            params: args,\n            type: \"wallet_addDeclareTransaction\",\n          }\n        : undefined,\n    );\n  };\n\n  return {\n    declare,\n    declareAsync,\n    ...result,\n  };\n}\n","import type {\n  AccountInterface,\n  BigNumberish,\n  DeployContractResponse,\n  InvocationsDetails,\n  RawArgs,\n} from \"starknet\";\n\nimport {\n  type UseMutationProps,\n  type UseMutationResult,\n  useMutation,\n} from \"../query\";\n\nimport { useAccount } from \"./use-account\";\n\nexport type DeployAccountVariables = {\n  /** The class hash of the contract to deploy. */\n  classHash?: string;\n  /** The constructor arguments. */\n  constructorCalldata?: RawArgs;\n  /** Address salt. */\n  addressSalt?: BigNumberish;\n  /** Contract address. */\n  contractAddress?: string;\n  /** Transaction options. */\n  options?: InvocationsDetails;\n};\n\nexport type UseDeployAccountProps = DeployAccountVariables &\n  UseMutationProps<DeployContractResponse, Error, DeployAccountVariables>;\n\ntype MutationResult = UseMutationResult<\n  DeployContractResponse,\n  Error,\n  DeployAccountVariables\n>;\n\nexport type UseDeployAccountResult = Omit<\n  MutationResult,\n  \"mutate\" | \"mutateAsync\"\n> & {\n  /** Deploy account. */\n  deployAccount: MutationResult[\"mutate\"];\n\n  /** Deploy account. */\n  deployAccountAsync: MutationResult[\"mutateAsync\"];\n};\n\n/**\n * Hook for deploying a contract.\n *\n * @remarks\n *\n * This hook deploys a new contract from the currently connected account.\n */\nexport function useDeployAccount({\n  classHash,\n  constructorCalldata,\n  addressSalt,\n  contractAddress,\n  options,\n  ...props\n}: UseDeployAccountProps): UseDeployAccountResult {\n  const { account } = useAccount();\n  const { mutate, mutateAsync, ...result } = useMutation({\n    mutationKey: mutationKey({\n      account,\n      classHash,\n      constructorCalldata,\n      addressSalt,\n      contractAddress,\n      options,\n    }),\n    mutationFn: mutationFn({\n      account,\n      classHash,\n      constructorCalldata,\n      addressSalt,\n      contractAddress,\n      options,\n    }),\n    ...props,\n  });\n\n  return {\n    deployAccount: mutate,\n    deployAccountAsync: mutateAsync,\n    ...result,\n  };\n}\n\nfunction mutationKey(\n  props: { account?: AccountInterface } & Partial<DeployAccountVariables>,\n) {\n  return [{ entity: \"deployAccount\", ...props }] as const;\n}\n\nfunction mutationFn({\n  account,\n  classHash,\n  constructorCalldata,\n  addressSalt,\n  contractAddress,\n  options,\n}: { account?: AccountInterface } & Partial<DeployAccountVariables>) {\n  return async () => {\n    if (!account) throw new Error(\"account is required\");\n    if (!classHash) throw new Error(\"classHash is required\");\n    return await account.deployAccount(\n      { classHash, constructorCalldata, addressSalt, contractAddress },\n      options,\n    );\n  };\n}\n","import { useStarknet } from \"../context/starknet\";\nimport {\n  type UseMutationProps,\n  type UseMutationResult,\n  useMutation,\n} from \"../query\";\n\ntype MutationResult = UseMutationResult<void, Error, void>;\n\nexport type UseDisconnectProps = UseMutationProps<void, Error, void>;\n\n/** Value returned from `useDisconnect`. */\nexport type UseDisconnectResult = Omit<\n  MutationResult,\n  \"mutate\" | \"mutateAsync\"\n> & {\n  /** Disconnect wallet. */\n  disconnect: MutationResult[\"mutate\"];\n  /** Disconnect wallet. */\n  disconnectAsync: MutationResult[\"mutateAsync\"];\n};\n\n/**\n *\n * Hook for disconnecting connected wallet.\n */\nexport function useDisconnect(\n  props: UseDisconnectProps = {},\n): UseDisconnectResult {\n  const { disconnect, chain } = useStarknet();\n\n  const { mutate, mutateAsync, ...result } = useMutation({\n    mutationKey: [{ entity: \"disconnect\", chainId: chain.name }],\n    mutationFn: disconnect,\n    ...props,\n  });\n\n  return {\n    disconnect: mutate,\n    disconnectAsync: mutateAsync,\n    ...result,\n  };\n}\n","import { useMemo } from \"react\";\nimport type {\n  AccountInterface,\n  Call,\n  EstimateFeeDetails,\n  EstimateFeeResponse,\n} from \"starknet\";\n\nimport { type UseQueryProps, type UseQueryResult, useQuery } from \"../query\";\n\nimport { useAccount } from \"./use-account\";\nimport { useInvalidateOnBlock } from \"./use-invalidate-on-block\";\n\nexport type EstimateFeesArgs = {\n  /** List of smart contract calls to estimate. */\n  calls?: Call[];\n  /** Estimate Fee options. */\n  options?: EstimateFeeDetails;\n};\n\n/** Options for `useEstimateFees`. */\nexport type UseEstimateFeesProps = EstimateFeesArgs &\n  UseQueryProps<\n    EstimateFeeResponse,\n    Error,\n    EstimateFeeResponse,\n    ReturnType<typeof queryKey>\n  > & {\n    /** Refresh data at every block. */\n    watch?: boolean;\n  };\n\n/** Value returned from `useEstimateFees`. */\nexport type UseEstimateFeesResult = UseQueryResult<EstimateFeeResponse, Error>;\n\n/**\n * Hook to estimate fees for smart contract calls.\n *\n * @remarks\n *\n * The hook only performs estimation if the `calls` is not undefined.\n */\nexport function useEstimateFees({\n  calls,\n  options,\n  watch = false,\n  enabled: enabled_ = true,\n  ...props\n}: UseEstimateFeesProps): UseEstimateFeesResult {\n  const { account } = useAccount();\n\n  const queryKey_ = useMemo(\n    () => queryKey({ calls, options }),\n    [calls, options],\n  );\n\n  const enabled = useMemo(() => Boolean(enabled_ && calls), [enabled_, calls]);\n\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_,\n  });\n\n  return useQuery({\n    queryKey: queryKey_,\n    queryFn: queryFn({\n      account,\n      calls,\n      options,\n    }),\n    enabled,\n    ...props,\n  });\n}\n\nfunction queryKey({ calls, options }: EstimateFeesArgs) {\n  return [\n    {\n      entity: \"estimateInvokeFee\",\n      calls,\n      options,\n    },\n  ] as const;\n}\n\nfunction queryFn({\n  account,\n  calls,\n  options,\n}: { account?: AccountInterface } & EstimateFeesArgs) {\n  return async () => {\n    if (!account) throw new Error(\"account is required\");\n    if (!calls || calls.length === 0) throw new Error(\"calls are required\");\n    return account?.estimateInvokeFee(calls, options);\n  };\n}\n","import { useStarknet } from \"../context/starknet\";\nimport type { Explorer } from \"../explorers\";\n\n/** Access the current explorer, should be inside a StarknetConfig. */\nexport function useExplorer(): Explorer {\n  const { explorer, chain } = useStarknet();\n  if (!explorer)\n    throw Error(\"Explorer is undefined. Try adding it to StarknetConfig.\");\n  const explorerInstance = explorer(chain);\n  if (!explorerInstance) throw Error(\"Explorer Instance is undefined\");\n  return explorerInstance;\n}\n","import type { Address } from \"@starknet-react/chains\";\n\nimport {\n  type BlockNumber,\n  BlockTag,\n  type Nonce,\n  type ProviderInterface,\n} from \"starknet\";\n\nimport { useStarknet } from \"../context/starknet\";\nimport { type UseQueryProps, type UseQueryResult, useQuery } from \"../query\";\n\n/** Arguments for `useNonceForAddress`. */\nexport type UseNonceForAddressProps = UseQueryProps<\n  Nonce,\n  Error,\n  Nonce,\n  ReturnType<typeof queryKey>\n> & {\n  /** Address to fetch nonce for. */\n  address: Address;\n  /** Identifier for the block to fetch. */\n  blockIdentifier?: BlockNumber;\n};\n\n/** Value returned from `useNonceForAddress`. */\nexport type UseNonceForAddressResult = UseQueryResult<Nonce, Error>;\n\n/**\n * Hook for fetching the nonce for the given address.\n */\nexport function useNonceForAddress({\n  address,\n  blockIdentifier = BlockTag.LATEST,\n  ...props\n}: UseNonceForAddressProps): UseNonceForAddressResult {\n  const { provider } = useStarknet();\n\n  return useQuery({\n    queryKey: queryKey({ address, blockIdentifier }),\n    queryFn: queryFn({ address, provider, blockIdentifier }),\n    ...props,\n  });\n}\n\nfunction queryKey({\n  address,\n  blockIdentifier,\n}: { address: Address; blockIdentifier: BlockNumber }) {\n  return [{ entity: \"nonce\", blockIdentifier, address }] as const;\n}\n\nfunction queryFn({\n  provider,\n  blockIdentifier,\n  address,\n}: {\n  provider: ProviderInterface;\n  address: Address;\n  blockIdentifier: BlockNumber;\n}) {\n  return async () => {\n    const nonce = await provider.getNonceForAddress(address, blockIdentifier);\n    return nonce;\n  };\n}\n","import type { Address } from \"@starknet-react/chains\";\nimport type {\n  Abi,\n  ExtractAbiFunction,\n  ExtractAbiFunctionNames,\n  ExtractArgs,\n  FunctionRet,\n} from \"abi-wan-kanabi/dist/kanabi\";\nimport type { BlockNumber } from \"starknet\";\n\nimport type { UseQueryProps, UseQueryResult } from \"../query\";\n\nimport { type CallQueryKey, type UseCallProps, useCall } from \"./use-call\";\n\ntype Result<\n  TAbi extends Abi,\n  TFunctionName extends ExtractAbiFunctionNames<TAbi>,\n> = FunctionRet<TAbi, TFunctionName>;\n\n/** Options for `useReadContract`. */\nexport type UseReadContractProps<\n  TAbi extends Abi,\n  TFunctionName extends ExtractAbiFunctionNames<TAbi>,\n> = UseQueryProps<\n  Result<TAbi, TFunctionName>,\n  Error,\n  Result<TAbi, TFunctionName>,\n  ReturnType<CallQueryKey>\n> & {\n  /** The target contract's ABI.\n   *\n   * @remarks\n   *\n   * You must pass ABI as const\n   *\n   */\n  abi?: TAbi;\n  /** The target contract's address. */\n  address?: Address;\n  /** Refresh data at every block. */\n  watch?: boolean;\n  /** The contract's function name. */\n  functionName: TFunctionName;\n  /** Read arguments. */\n  args?: ExtractArgs<TAbi, ExtractAbiFunction<TAbi, TFunctionName>>;\n  /** Block identifier used when performing call. */\n  blockIdentifier?: BlockNumber;\n};\n\n/** Value returned from `useReadContract`. */\nexport type UseReadContractResult<\n  TAbi extends Abi,\n  TFunctionName extends ExtractAbiFunctionNames<TAbi>,\n> = UseQueryResult<Result<TAbi, TFunctionName>, Error>;\n\n/**\n * Perform a read-only contract call. If the specified block identifier is pending,\n * the hook will periodically refetch data automatically.\n *\n * @remarks\n *\n * - The hook only performs a call if the target `abi`, `address`,\n * `functionName`, and `args` are not undefined.\n *\n * - You must pass `abi` as `const` for autocomplete to work.\n */\nexport function useReadContract<\n  TAbi extends Abi,\n  TFunctionName extends ExtractAbiFunctionNames<TAbi>,\n>(props: UseReadContractProps<TAbi, TFunctionName>) {\n  return useCall(props as UseCallProps) as UseReadContractResult<\n    TAbi,\n    TFunctionName\n  >;\n}\n","import type { Call as RequestCall } from \"@starknet-io/types-js\";\nimport type { Call } from \"starknet\";\nimport {\n  type RequestArgs,\n  type RequestResult,\n  type UseWalletRequestProps,\n  type UseWalletRequestResult,\n  useWalletRequest,\n} from \"./use-wallet-request\";\n\nexport type UseSendTransactionArgs = {\n  /** List of smart contract calls to execute. */\n  calls?: Call[];\n};\n\nexport type UseSendTransactionProps = UseSendTransactionArgs &\n  Omit<\n    UseWalletRequestProps<\"wallet_addInvokeTransaction\">,\n    keyof RequestArgs<\"wallet_addInvokeTransaction\">\n  >;\n\nexport type UseSendTransactionResult = Omit<\n  UseWalletRequestResult<\"wallet_addInvokeTransaction\">,\n  \"request\" | \"requestAsync\"\n> & {\n  send: (args?: Call[]) => void;\n  sendAsync: (\n    args?: Call[],\n  ) => Promise<RequestResult<\"wallet_addInvokeTransaction\">>;\n};\n\n/** Hook to send one or several transaction(s) to the network. */\nexport function useSendTransaction(\n  props: UseSendTransactionProps,\n): UseSendTransactionResult {\n  const { calls, ...rest } = props;\n\n  const params = calls ? { calls: transformCalls(calls) } : undefined;\n\n  const { request, requestAsync, ...result } = useWalletRequest({\n    type: \"wallet_addInvokeTransaction\",\n    params,\n    ...rest,\n  });\n\n  const send = (args?: Call[]) => {\n    return request(\n      args\n        ? {\n            params: { calls: transformCalls(args) },\n            type: \"wallet_addInvokeTransaction\",\n          }\n        : undefined,\n    );\n  };\n\n  const sendAsync = (args?: Call[]) => {\n    return requestAsync(\n      args\n        ? {\n            params: { calls: transformCalls(args) },\n            type: \"wallet_addInvokeTransaction\",\n          }\n        : undefined,\n    );\n  };\n\n  return {\n    send,\n    sendAsync,\n    ...result,\n  };\n}\n\nfunction transformCalls(calls: Call[]) {\n  return calls.map(\n    (call) =>\n      ({\n        contract_address: call.contractAddress,\n        entry_point: call.entrypoint,\n        calldata: call.calldata,\n      }) as RequestCall,\n  );\n}\n","import type { TypedData } from \"@starknet-io/types-js\";\n\nimport {\n  type RequestArgs,\n  type RequestResult,\n  type UseWalletRequestProps,\n  type UseWalletRequestResult,\n  useWalletRequest,\n} from \"./use-wallet-request\";\n\nexport type UseSignTypedDataArgs = TypedData;\n\nexport type UseSignTypedDataProps = Omit<\n  UseWalletRequestProps<\"wallet_signTypedData\">,\n  keyof RequestArgs<\"wallet_signTypedData\">\n> & {\n  params?: UseSignTypedDataArgs;\n};\n\nexport type UseSignTypedDataResult = Omit<\n  UseWalletRequestResult<\"wallet_signTypedData\">,\n  \"request\" | \"requestAsync\"\n> & {\n  signTypedData: (args?: UseSignTypedDataArgs) => void;\n  signTypedDataAsync: (\n    args?: UseSignTypedDataArgs,\n  ) => Promise<RequestResult<\"wallet_signTypedData\">>;\n};\n\nexport function useSignTypedData(\n  props: UseSignTypedDataProps,\n): UseSignTypedDataResult {\n  const { params, ...rest } = props;\n\n  const { request, requestAsync, ...result } = useWalletRequest({\n    type: \"wallet_signTypedData\",\n    params,\n    ...rest,\n  });\n\n  const signTypedData = (args?: UseSignTypedDataArgs) => {\n    return request(\n      args\n        ? {\n            params: args,\n            type: \"wallet_signTypedData\",\n          }\n        : undefined,\n    );\n  };\n\n  const signTypedDataAsync = (args?: UseSignTypedDataArgs) => {\n    return requestAsync(\n      args\n        ? {\n            params: args,\n            type: \"wallet_signTypedData\",\n          }\n        : undefined,\n    );\n  };\n\n  return {\n    signTypedData,\n    signTypedDataAsync,\n    ...result,\n  };\n}\n","import type { Address } from \"@starknet-react/chains\";\nimport { useMemo } from \"react\";\nimport {\n  CallData,\n  Provider,\n  type ProviderInterface,\n  starknetId,\n} from \"starknet\";\n\nimport { type UseQueryProps, type UseQueryResult, useQuery } from \"../query\";\n\nimport { useNetwork } from \"./use-network\";\nimport { useProvider } from \"./use-provider\";\n\nexport type UseStarkAddressProps = UseQueryProps<\n  string,\n  Error,\n  string,\n  ReturnType<typeof queryKey>\n> & {\n  /** Stark name. */\n  name?: string;\n  /** Naming contract to use . */\n  contract?: Address;\n};\n\nexport type UseStarkAddressResult = UseQueryResult<string, Error>;\n\n/**\n * Hook to get the address associated to a stark name.\n *\n * @remarks\n *\n * This hook fetches the address of the specified stark name\n * It defaults to the starknetID contract but a different contract can be targetted by specifying its address\n * If stark name does not have an associated address, it will return \"0x0\"\n *\n */\nexport function useStarkAddress({\n  name,\n  contract,\n  enabled: enabled_ = true,\n  ...props\n}: UseStarkAddressProps): UseStarkAddressResult {\n  const { provider } = useProvider();\n  const { chain } = useNetwork();\n\n  const enabled = useMemo(() => Boolean(enabled_ && name), [enabled_, name]);\n\n  return useQuery({\n    queryKey: queryKey({ name, contract, network: chain.network }),\n    queryFn: queryFn({ name, contract, provider, network: chain.network }),\n    enabled,\n    ...props,\n  });\n}\n\nfunction queryKey({\n  name,\n  contract,\n  network,\n}: {\n  name?: string;\n  contract?: string;\n  network?: string;\n}) {\n  return [{ entity: \"addressFromStarkName\", name, contract, network }] as const;\n}\n\nfunction queryFn({\n  name,\n  contract,\n  provider,\n  network,\n}: UseStarkAddressProps & { provider: ProviderInterface; network: string }) {\n  return async () => {\n    if (!name) throw new Error(\"name is required\");\n\n    const namingContract = contract ?? StarknetIdNamingContract[network];\n    const p = new Provider(provider);\n    const encodedDomain = encodeDomain(name);\n    const result = await p.callContract({\n      contractAddress: namingContract as string,\n      entrypoint: \"domain_to_address\",\n      calldata: CallData.compile({ domain: encodedDomain, hint: [] }),\n    });\n\n    // StarknetID returns 0x0 if no name is found, but that can be dangerous\n    // since we can't expect the user to know that 0x0 is not a valid address.\n    if (BigInt(result[0]) === BigInt(0)) throw new Error(\"Address not found\");\n\n    return result[0];\n  };\n}\n\nconst StarknetIdNamingContract: Record<string, string> = {\n  sepolia: \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\",\n  mainnet: \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\",\n};\n\nconst encodeDomain = (domain: string): string[] => {\n  if (!domain) return [\"0\"];\n\n  const encoded = [];\n  for (const subdomain of domain.replace(\".stark\", \"\").split(\".\"))\n    encoded.push(starknetId.useEncoded(subdomain).toString(10));\n  return encoded;\n};\n","import type { Address } from \"@starknet-react/chains\";\nimport { useMemo } from \"react\";\nimport {\n  Call,\n  CallData,\n  Provider,\n  type ProviderInterface,\n  starknetId,\n} from \"starknet\";\n\nimport { type UseQueryProps, type UseQueryResult, useQuery } from \"../query\";\n\nimport { useNetwork } from \"./use-network\";\nimport { useProvider } from \"./use-provider\";\n\n/** Arguments for `useStarkName` hook. */\nexport type StarkNameArgs = UseQueryProps<\n  string,\n  Error,\n  string,\n  ReturnType<typeof queryKey>\n> & {\n  /** Account address. */\n  address?: Address;\n  /** Naming contract to use . */\n  contract?: Address;\n};\n\n/** Value returned by `useStarkName` hook. */\nexport type StarkNameResult = UseQueryResult<string, Error>;\n\n/**\n * Hook for fetching Stark name for address.\n *\n * @remarks\n *\n * This hook fetches the stark name of the specified address.\n * It defaults to the starknet.id contract but a different contract can be\n * targetted by specifying its contract address\n * If address does not have a stark name, it will return \"stark\"\n */\nexport function useStarkName({\n  address,\n  contract,\n  enabled: enabled_ = true,\n  ...props\n}: StarkNameArgs): StarkNameResult {\n  const { provider } = useProvider();\n  const { chain } = useNetwork();\n\n  const enabled = useMemo(\n    () => Boolean(enabled_ && address),\n    [enabled_, address],\n  );\n\n  return useQuery({\n    queryKey: queryKey({ address, contract, network: chain.network }),\n    queryFn: queryFn({ address, contract, provider, network: chain.network }),\n    enabled,\n    ...props,\n  });\n}\n\nfunction queryKey({\n  address,\n  contract,\n  network,\n}: {\n  address?: string;\n  contract?: string;\n  network?: string;\n}) {\n  return [{ entity: \"starkName\", address, contract, network }] as const;\n}\n\nfunction queryFn({\n  address,\n  contract,\n  provider,\n  network,\n}: StarkNameArgs & { provider: ProviderInterface; network: string }) {\n  return async () => {\n    if (!address) throw new Error(\"address is required\");\n\n    const namingContract = contract ?? StarknetIdNamingContract[network];\n    const p = new Provider(provider);\n    return await p.getStarkName(address, namingContract);\n  };\n}\n\nconst StarknetIdNamingContract: Record<string, string> = {\n  sepolia: \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\",\n  mainnet: \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\",\n};\n","import type { Address } from \"@starknet-react/chains\";\nimport { useMemo } from \"react\";\nimport {\n  CairoCustomEnum,\n  Provider,\n  type ProviderInterface,\n  type RawArgsArray,\n  cairo,\n  hash,\n  shortString,\n  starknetId,\n} from \"starknet\";\n\nimport { type UseQueryProps, type UseQueryResult, useQuery } from \"../query\";\n\nimport { type StarknetTypedContract, useContract } from \"./use-contract\";\nimport { useNetwork } from \"./use-network\";\nimport { useProvider } from \"./use-provider\";\n\n/** Arguments for `useStarkProfile` hook. */\nexport type StarkProfileArgs = UseQueryProps<\n  GetStarkprofileResponse,\n  Error,\n  GetStarkprofileResponse,\n  ReturnType<typeof queryKey>\n> & {\n  /** Account address. */\n  address?: Address;\n  /** Get Starknet ID default pfp url if no profile picture is set */\n  useDefaultPfp?: boolean;\n  /** Naming contract to use. */\n  namingContract?: Address;\n  /** Identity contract to use. */\n  identityContract?: Address;\n};\n\n/** Value returned by `useStarkProfile` hook. */\nexport type GetStarkprofileResponse = {\n  name: string;\n  /** Metadata url of the NFT set as profile picture. */\n  profile?: string;\n  /** Profile picture url. */\n  profilePicture?: string;\n  twitter?: string;\n  github?: string;\n  discord?: string;\n  proofOfPersonhood: boolean;\n};\n\nexport type UseStarkProfileResult = UseQueryResult<\n  GetStarkprofileResponse,\n  Error\n>;\n\ntype Contract = StarknetTypedContract<typeof multicallABI>;\n\n/**\n * Hook for fetching Stark profile for address.\n *\n * @remarks\n *\n * This hook fetches the stark name of the specified address, profile picture url,\n * social networks ids, and proof of personhood a user has set on its starknetid.\n * It defaults to the starknet.id naming and identity contracts but different contracts can be\n * targetted by specifying their contract addresses\n * If address does not have a stark name, it will return \"stark\"\n *\n */\nexport function useStarkProfile({\n  address,\n  useDefaultPfp = true,\n  namingContract,\n  identityContract,\n  enabled: enabled_ = true,\n\n  ...props\n}: StarkProfileArgs): UseStarkProfileResult {\n  const { provider } = useProvider();\n  const { chain } = useNetwork();\n  if (!StarknetIdcontracts[chain.network])\n    throw new Error(\"Network not supported\");\n  const { contract: multicallContract } = useContract({\n    abi: multicallABI,\n    address: StarknetIdcontracts[chain.network][\"multicall\"],\n  });\n\n  const enabled = useMemo(\n    () => Boolean(enabled_ && address),\n    [enabled_, address],\n  );\n\n  const { refetchInterval, ...rest } = props;\n\n  return useQuery({\n    queryKey: queryKey({\n      address,\n      namingContract,\n      identityContract,\n      network: chain.network,\n      useDefaultPfp,\n    }),\n    queryFn: queryFn({\n      address,\n      useDefaultPfp,\n      namingContract,\n      provider,\n      network: chain.network,\n      identityContract,\n      multicallContract,\n    }),\n    enabled,\n    refetchInterval,\n    ...rest,\n  });\n}\n\nfunction queryKey({\n  address,\n  namingContract,\n  identityContract,\n  network,\n  useDefaultPfp,\n}: {\n  address?: string;\n  namingContract?: string;\n  identityContract?: string;\n  network?: string;\n  useDefaultPfp?: boolean;\n}) {\n  return [\n    {\n      entity: \"starkprofile\",\n      address,\n      namingContract,\n      identityContract,\n      network,\n      useDefaultPfp,\n    },\n  ] as const;\n}\n\nfunction queryFn({\n  address,\n  useDefaultPfp,\n  namingContract,\n  identityContract,\n  provider,\n  network,\n  multicallContract,\n}: StarkProfileArgs & {\n  provider: ProviderInterface;\n  multicallContract?: Contract;\n  network?: string;\n}) {\n  return async () => {\n    throw new Error(\"Not implemented\");\n    /*\n    if (!address) throw new Error(\"address is required\");\n    if (!multicallContract) throw new Error(\"multicallContract is required\");\n    if (!network) throw new Error(\"network is required\");\n\n    const contracts = StarknetIdcontracts[network];\n    const identity = identityContract ?? contracts[\"identity\"];\n    const naming = namingContract ?? contracts[\"naming\"];\n\n    // get decoded starkname\n    const p = new Provider(provider);\n    const name = await p.getStarkName(address, naming);\n\n    const data = await multicallContract.call(\"aggregate\", [\n      [\n        {\n          execution: staticExecution(),\n          to: hardcoded(naming),\n          selector: hardcoded(hash.getSelectorFromName(\"address_to_domain\")),\n          calldata: [hardcoded(address)],\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(naming),\n          selector:\n            network === \"mainnet\"\n              ? hardcoded(hash.getSelectorFromName(\"domain_to_token_id\"))\n              : hardcoded(hash.getSelectorFromName(\"domain_to_id\")),\n          calldata: [arrayReference(0, 0)],\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            reference(1, 0),\n            hardcoded(shortString.encodeShortString(\"twitter\")),\n            hardcoded(contracts[\"verifier\"] as string),\n            hardcoded(\"0\"),\n          ],\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            reference(1, 0),\n            hardcoded(shortString.encodeShortString(\"github\")),\n            hardcoded(contracts[\"verifier\"] as string),\n            hardcoded(\"0\"),\n          ],\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            reference(1, 0),\n            hardcoded(shortString.encodeShortString(\"discord\")),\n            hardcoded(contracts[\"verifier\"] as string),\n            hardcoded(\"0\"),\n          ],\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            reference(1, 0),\n            hardcoded(shortString.encodeShortString(\"proof_of_personhood\")),\n            hardcoded(contracts[\"verifier_pop\"] as string),\n            hardcoded(\"0\"),\n          ],\n        },\n        // PFP\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            reference(1, 0),\n            hardcoded(shortString.encodeShortString(\"nft_pp_contract\")),\n            hardcoded(contracts[\"verifier_pfp\"] as string),\n            hardcoded(\"0\"),\n          ],\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(\n            hash.getSelectorFromName(\"get_extended_verifier_data\"),\n          ),\n          calldata: [\n            reference(1, 0),\n            hardcoded(shortString.encodeShortString(\"nft_pp_id\")),\n            hardcoded(\"2\"),\n            hardcoded(contracts[\"verifier_pfp\"] as string),\n            hardcoded(\"0\"),\n          ],\n        },\n        {\n          execution: notEqual(6, 0, 0),\n          to: reference(6, 0),\n          selector: hardcoded(hash.getSelectorFromName(\"tokenURI\")),\n          calldata: [reference(7, 1), reference(7, 2)],\n        },\n      ],\n    ]);\n\n    if (Array.isArray(data)) {\n      const name =\n        data[0][0] !== BigInt(0)\n          ? starknetId.useDecoded(data[0].slice(1))\n          : undefined;\n      const twitter =\n        data[2][0] !== BigInt(0) ? data[2][0].toString() : undefined;\n      const github =\n        data[3][0] !== BigInt(0) ? data[3][0].toString() : undefined;\n      const discord =\n        data[4][0] !== BigInt(0) ? data[4][0].toString() : undefined;\n      const proofOfPersonhood = data[5][0] === BigInt(1);\n\n      const profile =\n        data.length === 9\n          ? data[8]\n              .slice(1)\n              .map((val) => shortString.decodeShortString(val.toString()))\n              .join(\"\")\n          : undefined;\n\n      // extract nft_image from profile data\n      const profilePicture = profile\n        ? profile.includes(\"base64\")\n          ? JSON.parse(atob(profile.split(\",\")[1].slice(0, -1))).image\n          : await fetchImageUrl(profile)\n        : useDefaultPfp\n          ? `https://starknet.id/api/identicons/${data[1][0].toString()}`\n          : undefined;\n\n      const res: GetStarkprofileResponse = {\n        name,\n        twitter,\n        github,\n        discord,\n        proofOfPersonhood,\n        profilePicture,\n        profile,\n      };\n\n      return res;\n    }\n\n    throw new Error(\"Error while fetching data\");\n    */\n  };\n}\n\n/*\nconst hardcoded = (arg: string | number) => {\n  return new CairoCustomEnum({\n    Hardcoded: arg,\n  });\n};\n\nconst reference = (call: number, pos: number) => {\n  return new CairoCustomEnum({\n    Reference: cairo.tuple(call, pos),\n  });\n};\n\nconst arrayReference = (call: number, pos: number) => {\n  return new CairoCustomEnum({\n    ArrayReference: cairo.tuple(call, pos),\n  });\n};\n\nconst staticExecution = () => {\n  return new CairoCustomEnum({\n    Static: {},\n  });\n};\n\nconst notEqual = (call: number, pos: number, value: number) => {\n  return new CairoCustomEnum({\n    IfNotEqual: cairo.tuple(call, pos, value),\n  });\n};\n\nconst fetchImageUrl = async (url: string): Promise<string> => {\n  try {\n    const response = await fetch(parseImageUrl(url));\n\n    if (!response.ok) {\n      throw new Error(\"Network response was not ok\");\n    }\n\n    const data = await response.json();\n\n    // Check if the \"image\" key exists and is not null\n    if (data.image) {\n      return data.image;\n    }\n\n    return \"Image is not set\";\n  } catch (error) {\n    console.error(\"There was a problem fetching the image URL:\", error);\n    return \"Error fetching data\";\n  }\n};\n*/\n\ntype StarknetIdContractTypes = {\n  [network: string]: {\n    naming: Address;\n    identity: Address;\n    verifier: Address;\n    verifier_pop: Address;\n    verifier_pfp: Address;\n    multicall: Address;\n  };\n};\n\nconst StarknetIdcontracts: StarknetIdContractTypes = {\n  sepolia: {\n    naming: \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\",\n    identity: \"0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda\",\n    verifier:\n      \"0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566\",\n    verifier_pop:\n      \"0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a\",\n    verifier_pfp:\n      \"0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02\",\n    multicall:\n      \"0x07a9013697371ce40d0306b4c810c6a4db9bfda119dd9ae1e8701c8e288d734b\",\n  },\n  mainnet: {\n    naming: \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\",\n    identity:\n      \"0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af\",\n    verifier:\n      \"0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf\",\n    verifier_pop:\n      \"0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4\",\n    verifier_pfp:\n      \"0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7\",\n    multicall:\n      \"0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970\",\n  },\n} as const;\n\n/*\nconst executeMulticallWithFallback = async (\n  contract: ContractInterface,\n  functionName: string,\n  initialCalldata: RawArgsArray,\n  fallbackCalldata: RawArgsArray,\n) => {\n  try {\n    // Attempt the initial call with the new hint parameter\n    return await contract.call(functionName, [initialCalldata]);\n  } catch (initialError) {\n    // If the initial call fails, try with the fallback calldata without the hint parameter\n    return await contract.call(functionName, [fallbackCalldata]);\n  }\n};\n\nconst getStarkProfileCalldata = (\n  address: string,\n  namingContract: string,\n  identityContract: string,\n  contracts: Record<string, string>,\n): {\n  initialCalldata: RawArgsArray;\n  fallbackCalldata: RawArgsArray;\n} => {\n  const initialCalldata: RawArgsArray = [];\n  const fallbackCalldata: RawArgsArray = [];\n\n  initialCalldata.push({\n    execution: staticExecution(),\n    to: hardcoded(namingContract),\n    selector: hardcoded(hash.getSelectorFromName(\"address_to_domain\")),\n    calldata: [hardcoded(address), hardcoded(\"0\")],\n  });\n  fallbackCalldata.push({\n    execution: staticExecution(),\n    to: hardcoded(namingContract),\n    selector: hardcoded(hash.getSelectorFromName(\"address_to_domain\")),\n    calldata: [hardcoded(address)],\n  });\n\n  const calls = [\n    {\n      execution: staticExecution(),\n      to: hardcoded(namingContract),\n      selector: hardcoded(hash.getSelectorFromName(\"domain_to_id\")),\n      calldata: [arrayReference(0, 0)],\n    },\n    {\n      execution: staticExecution(),\n      to: hardcoded(identityContract),\n      selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n      calldata: [\n        reference(1, 0),\n        hardcoded(shortString.encodeShortString(\"twitter\")),\n        hardcoded(contracts[\"verifier\"] as string),\n        hardcoded(\"0\"),\n      ],\n    },\n    {\n      execution: staticExecution(),\n      to: hardcoded(identityContract),\n      selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n      calldata: [\n        reference(1, 0),\n        hardcoded(shortString.encodeShortString(\"github\")),\n        hardcoded(contracts[\"verifier\"] as string),\n        hardcoded(\"0\"),\n      ],\n    },\n    {\n      execution: staticExecution(),\n      to: hardcoded(identityContract),\n      selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n      calldata: [\n        reference(1, 0),\n        hardcoded(shortString.encodeShortString(\"discord\")),\n        hardcoded(contracts[\"verifier\"] as string),\n        hardcoded(\"0\"),\n      ],\n    },\n    {\n      execution: staticExecution(),\n      to: hardcoded(identityContract),\n      selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n      calldata: [\n        reference(1, 0),\n        hardcoded(shortString.encodeShortString(\"proof_of_personhood\")),\n        hardcoded(contracts[\"verifier_pop\"] as string),\n        hardcoded(\"0\"),\n      ],\n    },\n    // PFP\n    {\n      execution: staticExecution(),\n      to: hardcoded(identityContract),\n      selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n      calldata: [\n        reference(1, 0),\n        hardcoded(shortString.encodeShortString(\"nft_pp_contract\")),\n        hardcoded(contracts[\"verifier_pfp\"] as string),\n        hardcoded(\"0\"),\n      ],\n    },\n    {\n      execution: staticExecution(),\n      to: hardcoded(identityContract),\n      selector: hardcoded(\n        hash.getSelectorFromName(\"get_extended_verifier_data\"),\n      ),\n      calldata: [\n        reference(1, 0),\n        hardcoded(shortString.encodeShortString(\"nft_pp_id\")),\n        hardcoded(\"2\"),\n        hardcoded(contracts[\"verifier_pfp\"] as string),\n        hardcoded(\"0\"),\n      ],\n    },\n    {\n      execution: notEqual(6, 0, 0),\n      to: reference(6, 0),\n      selector: hardcoded(hash.getSelectorFromName(\"tokenURI\")),\n      calldata: [reference(7, 1), reference(7, 2)],\n    },\n  ];\n  initialCalldata.push(...calls);\n  fallbackCalldata.push(...calls);\n\n  return { initialCalldata, fallbackCalldata };\n};\n\n*/\n\nconst multicallABI = [\n  {\n    name: \"ComposableMulticallImpl\",\n    type: \"impl\",\n    interface_name: \"composable_multicall::IComposableMulticall\",\n  },\n  {\n    name: \"composable_multicall::Execution\",\n    type: \"enum\",\n    variants: [\n      {\n        name: \"Static\",\n        type: \"()\",\n      },\n      {\n        name: \"IfEqual\",\n        type: \"(core::integer::u32, core::integer::u32, core::felt252)\",\n      },\n      {\n        name: \"IfNotEqual\",\n        type: \"(core::integer::u32, core::integer::u32, core::felt252)\",\n      },\n    ],\n  },\n  {\n    name: \"composable_multicall::DynamicFelt\",\n    type: \"enum\",\n    variants: [\n      {\n        name: \"Hardcoded\",\n        type: \"core::felt252\",\n      },\n      {\n        name: \"Reference\",\n        type: \"(core::integer::u32, core::integer::u32)\",\n      },\n    ],\n  },\n  {\n    name: \"composable_multicall::DynamicCalldata\",\n    type: \"enum\",\n    variants: [\n      {\n        name: \"Hardcoded\",\n        type: \"core::felt252\",\n      },\n      {\n        name: \"Reference\",\n        type: \"(core::integer::u32, core::integer::u32)\",\n      },\n      {\n        name: \"ArrayReference\",\n        type: \"(core::integer::u32, core::integer::u32)\",\n      },\n    ],\n  },\n  {\n    name: \"composable_multicall::DynamicCall\",\n    type: \"struct\",\n    members: [\n      {\n        name: \"execution\",\n        type: \"composable_multicall::Execution\",\n      },\n      {\n        name: \"to\",\n        type: \"composable_multicall::DynamicFelt\",\n      },\n      {\n        name: \"selector\",\n        type: \"composable_multicall::DynamicFelt\",\n      },\n      {\n        name: \"calldata\",\n        type: \"core::array::Array::<composable_multicall::DynamicCalldata>\",\n      },\n    ],\n  },\n  {\n    name: \"core::array::Span::<core::felt252>\",\n    type: \"struct\",\n    members: [\n      {\n        name: \"snapshot\",\n        type: \"@core::array::Array::<core::felt252>\",\n      },\n    ],\n  },\n  {\n    name: \"composable_multicall::IComposableMulticall\",\n    type: \"interface\",\n    items: [\n      {\n        name: \"aggregate\",\n        type: \"function\",\n        inputs: [\n          {\n            name: \"calls\",\n            type: \"core::array::Array::<composable_multicall::DynamicCall>\",\n          },\n        ],\n        outputs: [\n          {\n            type: \"core::array::Array::<core::array::Span::<core::felt252>>\",\n          },\n        ],\n        state_mutability: \"view\",\n      },\n    ],\n  },\n  {\n    kind: \"enum\",\n    name: \"composable_multicall::contract::ComposableMulticall::Event\",\n    type: \"event\",\n    variants: [],\n  },\n] as const;\n","import type { SwitchStarknetChainParameters } from \"@starknet-io/types-js\";\n\nimport {\n  type RequestArgs,\n  type RequestResult,\n  type UseWalletRequestProps,\n  type UseWalletRequestResult,\n  useWalletRequest,\n} from \"./use-wallet-request\";\n\nexport type UseSwitchChainArgs = SwitchStarknetChainParameters;\n\nexport type UseSwitchChainProps = Omit<\n  UseWalletRequestProps<\"wallet_switchStarknetChain\">,\n  keyof RequestArgs<\"wallet_switchStarknetChain\">\n> & {\n  params?: UseSwitchChainArgs;\n};\n\nexport type UseSwitchChainResult = Omit<\n  UseWalletRequestResult<\"wallet_switchStarknetChain\">,\n  \"request\" | \"requestAsync\"\n> & {\n  switchChain: (args?: UseSwitchChainArgs) => void;\n  switchChainAsync: (\n    args?: UseSwitchChainArgs,\n  ) => Promise<RequestResult<\"wallet_switchStarknetChain\">>;\n};\n\n/**\n * Hook to change the current network of the wallet.\n *\n */\nexport function useSwitchChain(\n  props: UseSwitchChainProps,\n): UseSwitchChainResult {\n  const { params, ...rest } = props;\n\n  const { request, requestAsync, ...result } = useWalletRequest({\n    type: \"wallet_switchStarknetChain\",\n    params,\n    ...rest,\n  });\n\n  const switchChain = (args?: UseSwitchChainArgs) => {\n    return request(\n      args\n        ? {\n            params: args,\n            type: \"wallet_switchStarknetChain\",\n          }\n        : undefined,\n    );\n  };\n\n  const switchChainAsync = (args?: UseSwitchChainArgs) => {\n    return requestAsync(\n      args\n        ? {\n            params: args,\n            type: \"wallet_switchStarknetChain\",\n          }\n        : undefined,\n    );\n  };\n\n  return {\n    switchChain,\n    switchChainAsync,\n    ...result,\n  };\n}\n","import type { Chain } from \"@starknet-react/chains\";\nimport { useMemo } from \"react\";\nimport type {\n  GetTransactionReceiptResponse,\n  ProviderInterface,\n} from \"starknet\";\n\nimport { useStarknet } from \"../context/starknet\";\nimport { type UseQueryProps, type UseQueryResult, useQuery } from \"../query\";\n\nimport { useInvalidateOnBlock } from \"./use-invalidate-on-block\";\n\n/** Arguments for the `useTransactionReceipt` hook. */\nexport type UseTransactionReceiptProps = UseQueryProps<\n  GetTransactionReceiptResponse,\n  Error,\n  GetTransactionReceiptResponse,\n  ReturnType<typeof queryKey>\n> & {\n  /** The transaction hash. */\n  hash?: string;\n  /** Refresh data at every block. */\n  watch?: boolean;\n};\n\nexport type UseTransactionReceiptResult = UseQueryResult<\n  GetTransactionReceiptResponse,\n  Error\n>;\n\n/**\n * Hook to fetch a single transaction receipt.\n *\n * @remarks\n *\n * This hook keeps a cache of receipts by chain and transaction hash\n * so that you can use the hook freely in your application without worrying\n * about sending duplicate network requests.\n *\n * If you need to refresh the transaction receipt data, set `watch: true` in\n * the props. The hook will periodically refresh the transaction data in the\n * background.\n *\n */\nexport function useTransactionReceipt({\n  hash,\n  watch,\n  enabled: enabled_ = true,\n  ...props\n}: UseTransactionReceiptProps): UseTransactionReceiptResult {\n  const { provider, chain } = useStarknet();\n\n  const queryKey_ = useMemo(() => queryKey({ chain, hash }), [chain, hash]);\n\n  const enabled = useMemo(() => Boolean(enabled_ && hash), [enabled_, hash]);\n\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_,\n  });\n\n  return useQuery({\n    queryKey: queryKey_,\n    queryFn: queryFn({ provider, hash }),\n    enabled,\n    ...props,\n  });\n}\n\nfunction queryKey({ chain, hash }: { chain?: Chain; hash?: string }) {\n  return [\n    { entity: \"transactionReceipt\", chainId: chain?.name, hash },\n  ] as const;\n}\n\nfunction queryFn({\n  provider,\n  hash,\n}: {\n  provider: ProviderInterface;\n  hash?: string;\n}) {\n  return async () => {\n    if (!hash) throw new Error(\"hash is required\");\n\n    return await provider.getTransactionReceipt(hash);\n  };\n}\n","import type { WatchAssetParameters } from \"@starknet-io/types-js\";\nimport {\n  type RequestArgs,\n  type RequestResult,\n  type UseWalletRequestProps,\n  type UseWalletRequestResult,\n  useWalletRequest,\n} from \"./use-wallet-request\";\n\nexport type UseWatchAssetArgs = WatchAssetParameters;\n\nexport type UseWatchAssetProps = Omit<\n  UseWalletRequestProps<\"wallet_watchAsset\">,\n  keyof RequestArgs<\"wallet_watchAsset\">\n> & {\n  params?: UseWatchAssetArgs;\n};\n\nexport type UseWatchAssetResult = Omit<\n  UseWalletRequestResult<\"wallet_watchAsset\">,\n  \"request\" | \"requestAsync\"\n> & {\n  watchAsset: (args?: UseWatchAssetArgs) => void;\n  watchAssetAsync: (\n    args?: UseWatchAssetArgs,\n  ) => Promise<RequestResult<\"wallet_watchAsset\">>;\n};\n\n/**\n * Hook to watch an asset in the wallet.\n *\n */\n\nexport function useWatchAsset(props: UseWatchAssetProps): UseWatchAssetResult {\n  const { params, ...rest } = props;\n\n  const { request, requestAsync, ...result } = useWalletRequest({\n    type: \"wallet_watchAsset\",\n    params,\n    ...rest,\n  });\n\n  const watchAsset = (args?: UseWatchAssetArgs) => {\n    return request(\n      args\n        ? {\n            params: args,\n            type: \"wallet_watchAsset\",\n          }\n        : undefined,\n    );\n  };\n\n  const watchAssetAsync = (args?: UseWatchAssetArgs) => {\n    return requestAsync(\n      args\n        ? {\n            params: args,\n            type: \"wallet_watchAsset\",\n          }\n        : undefined,\n    );\n  };\n\n  return {\n    watchAsset,\n    watchAssetAsync,\n    ...result,\n  };\n}\n"],"mappings":"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","names":["useCallback","useEffect","useState","useContext","jsx","useContext","useState","useCallback","state","useEffect","useCallback","useCallback","useMemo","BlockTag","useEffect","useState","queryKey","useState","useEffect","BlockTag","useMemo","queryKey","queryFn","BlockTag","BlockTag","queryKey","queryFn","useMemo","BlockTag","DEFAULT_FETCH_INTERVAL","BlockTag","useMemo","queryKey","queryFn","useCallback","useCallback","useMemo","useMemo","mutationKey","mutationFn","useMemo","useMemo","queryKey","queryFn","BlockTag","BlockTag","queryKey","queryFn","useMemo","useMemo","queryKey","queryFn","useMemo","Provider","useMemo","queryKey","queryFn","StarknetIdNamingContract","Provider","useMemo","useMemo","queryKey","queryFn","useMemo","useMemo","queryKey","queryFn"]}