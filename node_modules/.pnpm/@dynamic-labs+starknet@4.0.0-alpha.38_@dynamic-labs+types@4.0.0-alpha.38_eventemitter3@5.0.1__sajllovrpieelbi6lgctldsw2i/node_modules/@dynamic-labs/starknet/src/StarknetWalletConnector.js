'use client'
import { __awaiter } from '../_virtual/_tslib.js';
import { constants, num, Contract, cairo, WalletAccount, RpcProvider } from 'starknet';
import { WalletConnectorBase } from '@dynamic-labs/wallet-connector-core';
import { DynamicError } from '@dynamic-labs/utils';
import { Logger } from '@dynamic-labs/logger';
import { ETH_STARKNET_ADDRESS } from './constants.js';
import ETH_CONTRACT_ABI from './ethereumContractAbi.js';
import { formatTypedDataMessage } from './utils/convertors.js';
import { StarknetWallet } from './wallet/StarknetWallet.js';

class StarknetWalletConnector extends WalletConnectorBase {
    constructor(name, id, opts) {
        var _a;
        super(opts);
        this.ChainWallet = StarknetWallet;
        this.connectedChain = 'STARK';
        this.supportedChains = ['STARK'];
        this.switchNetworkOnlyFromWallet = true;
        /** required for metamask snap integration as MM snaps don't have event listeners */
        this.canSetEventListeners = true;
        this.name = name;
        this.id = id;
        this.starknetNetworks = opts.starknetNetworks;
        this.chainRpcProviders = opts.chainRpcProviders;
        (_a = this.chainRpcProviders) === null || _a === void 0 ? void 0 : _a.registerStarknetProviders();
        this.walletBookWallet = opts.walletBookWallet;
        this.logger = new Logger(this.name);
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getAddress();
        });
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            if ((_a = this.walletData) === null || _a === void 0 ? void 0 : _a.account) {
                return this.walletData.account;
            }
            this.logger.debug('[getAddress] Prompting new connection');
            const { wallet, data } = yield this.prompt({
                silently: false,
            });
            this.logger.debug(`[getAddress] Connection returned account: ${data === null || data === void 0 ? void 0 : data.account}, wallet: ${wallet}`);
            if (!wallet || !data) {
                return undefined;
            }
            this.wallet = wallet;
            this.walletData = data;
            this.setupEventListeners();
            return this.walletData.account;
        });
    }
    /**
     * returns starknet wallet network id
     */
    getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!((_a = this.walletData) === null || _a === void 0 ? void 0 : _a.chainId)) {
                return undefined;
            }
            return num.toHex(this.walletData.chainId);
        });
    }
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const wallet = yield this.getWalletAccount();
            if (!wallet) {
                this.logger.error('Could not find provider for getting balance');
                return undefined;
            }
            const contract = new Contract(ETH_CONTRACT_ABI, ETH_STARKNET_ADDRESS, wallet);
            try {
                const { balance } = yield contract.balanceOf(address);
                /**
                 * Dividing by 1e18 as the returned balance is a Gwei number.
                 * Read more here: https://www.investopedia.com/terms/g/gwei-ethereum.asp#toc-what-is-gwei
                 */
                return (Number(cairo.uint256(balance.low).low) / 1e18).toFixed(6);
            }
            catch (error) {
                this.logger.error(error);
                throw new DynamicError('Something went wrong');
            }
        });
    }
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            const [walletAddress, chainId] = yield Promise.all([
                this.getAddress(),
                this.getNetwork(),
            ]);
            const assertions = [
                [walletAddress, 'No address for wallet'],
                [chainId, 'No chainId for wallet'],
                [this.wallet, 'No wallet provider'],
            ];
            for (const [value, message] of assertions) {
                if (!value) {
                    this.logger.error(`[signMessage] ${message}. Make sure \`connect\` was called first`);
                    return undefined;
                }
            }
            const encodedMessage = formatTypedDataMessage(messageToSign, chainId);
            // justification: performing assertion above
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const signature = yield this.wallet.request({
                params: encodedMessage,
                type: 'wallet_signTypedData',
            });
            return signature === null || signature === void 0 ? void 0 : signature.join(',');
        });
    }
    getWalletAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.wallet) {
                return undefined;
            }
            return new WalletAccount(yield this.getProvider(), this.wallet);
        });
    }
    getProvider() {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcUrl = yield this.resolveRpcUrl();
            this.logger.debug(`[getProvider] using rpcUrl: ${rpcUrl}`);
            return new RpcProvider({ nodeUrl: rpcUrl });
        });
    }
    isInstalledOnBrowser() {
        return Boolean(window[`starknet_${this.id}`]);
    }
    endSession() {
        return __awaiter(this, void 0, void 0, function* () {
            this.teardownEventListeners();
            this.wallet = undefined;
            this.walletData = undefined;
        });
    }
    setupEventListeners() {
        if (!this.canSetEventListeners)
            return;
        if (!this.wallet) {
            this.logger.debug('[setupEventListeners] Not connected, returning early');
            return;
        }
        this.handleAccountChange = (accounts) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            this.logger.debug(`[accountsChanged] Received argument: ${accounts === null || accounts === void 0 ? void 0 : accounts.toString()}`);
            if (!accounts || accounts[0] === null) {
                this.emit('disconnect');
                return;
            }
            const [address] = accounts;
            if (address) {
                this.walletData = {
                    account: address,
                    chainId: (_a = this.walletData) === null || _a === void 0 ? void 0 : _a.chainId,
                };
                this.emit('accountChange', { accounts: [address.toString()] });
            }
        });
        this.handleNetworkChange = (chainId) => __awaiter(this, void 0, void 0, function* () {
            var _b;
            this.logger.debug(`[networkChanged] Received argument: ${chainId === null || chainId === void 0 ? void 0 : chainId.toString()}`);
            if (!chainId) {
                this.emit('disconnect');
                return;
            }
            this.walletData = {
                account: (_b = this.walletData) === null || _b === void 0 ? void 0 : _b.account,
                chainId: BigInt(chainId),
            };
            this.emit('chainChange', { chain: chainId });
        });
        this.logger.debug('[setupEventListeners] Setting up accountsChanged and networkChanged');
        this.wallet.on('accountsChanged', this.handleAccountChange);
        this.wallet.on('networkChanged', this.handleNetworkChange);
    }
    teardownEventListeners() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            if (!this.canSetEventListeners)
                return;
            if (this.handleAccountChange) {
                (_a = this.wallet) === null || _a === void 0 ? void 0 : _a.off('accountsChanged', this.handleAccountChange);
                this.handleAccountChange = undefined;
            }
            if (this.handleNetworkChange) {
                (_b = this.wallet) === null || _b === void 0 ? void 0 : _b.off('networkChanged', this.handleNetworkChange);
                this.handleNetworkChange = undefined;
            }
        });
    }
    resolveRpcUrl() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const chainId = yield this.getNetwork();
            if (!chainId) {
                this.logger.warn('[resolveRpcUrl] `getNetwork` returned undefined');
                return undefined;
            }
            const networkConfig = this.starknetNetworks.find((config) => config.chainId === chainId);
            if (!networkConfig) {
                this.logger.warn(`[resolveRpcUrl] Network configuration for chainId \`${chainId}\` is not found in starknetNetworks`);
                return undefined;
            }
            return (((_a = networkConfig.privateCustomerRpcUrls) === null || _a === void 0 ? void 0 : _a[0]) || networkConfig.rpcUrls[0]);
        });
    }
    mapChainIdToNetworkName(chainIdOrNetworkName) {
        if (chainIdOrNetworkName === constants.StarknetChainId.SN_MAIN ||
            chainIdOrNetworkName === constants.NetworkName.SN_MAIN) {
            return constants.NetworkName.SN_MAIN;
        }
        else if (chainIdOrNetworkName === constants.StarknetChainId.SN_SEPOLIA ||
            chainIdOrNetworkName === constants.NetworkName.SN_SEPOLIA) {
            return constants.NetworkName.SN_SEPOLIA;
        }
        else {
            this.logger.error('Unknown chainId', chainIdOrNetworkName);
            return undefined;
        }
    }
}

export { StarknetWalletConnector };
