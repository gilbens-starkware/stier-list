'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../_virtual/_tslib.cjs');
var typesJs = require('@starknet-io/types-js');
var utils = require('@dynamic-labs/utils');
var StarknetWalletConnector = require('../../StarknetWalletConnector.cjs');

class Injected extends StarknetWalletConnector.StarknetWalletConnector {
    constructor(name, id, props) {
        super(name, id, props);
        this.overrideKey = props.overrideKey;
    }
    prompt(options) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const wallet = this.getWindowWallet();
            if (!wallet) {
                throw new utils.DynamicError('No wallet available to send RPC requests to');
            }
            this.logger.debug('[prompt] Sending wallet_requestAccounts with silent_mode:', options.silently);
            const accounts = yield wallet.request({
                params: {
                    silent_mode: options.silently,
                },
                type: 'wallet_requestAccounts',
            });
            this.logger.debug('[prompt] Received from wallet_requestAccounts:', accounts);
            if (accounts.length === 0) {
                return {
                    data: {
                        account: undefined,
                        chainId: undefined,
                    },
                    wallet,
                };
            }
            const [account] = accounts;
            this.logger.debug('[prompt] Sending wallet_requestChaindId');
            const chainId = yield wallet.request({
                type: 'wallet_requestChainId',
            });
            this.logger.debug('[prompt] Received from wallet_requestChainId:', chainId);
            return {
                data: {
                    account,
                    chainId: BigInt(chainId),
                },
                wallet,
            };
        });
    }
    getAddress() {
        const _super = Object.create(null, {
            getAddress: { get: () => super.getAddress }
        });
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            if (this.isInstalledOnBrowser()) {
                return _super.getAddress.call(this);
            }
            const inAppBrowserBase = (_a = this.walletBookWallet.mobile) === null || _a === void 0 ? void 0 : _a.inAppBrowser;
            if (!inAppBrowserBase || !utils.isMobile()) {
                return undefined;
            }
            const inAppBrowserTemplate = utils.template(inAppBrowserBase);
            const deepLink = inAppBrowserTemplate({
                encodedDappURI: window.location.toString().replace(/http(s)?:\/\//, ''),
            });
            window.location.href = deepLink;
            return undefined;
        });
    }
    getConnectedAccounts() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            if ((_a = this.walletData) === null || _a === void 0 ? void 0 : _a.account) {
                this.logger.debug('[getConnectedAccounts] Found existing account:', this.walletData.account);
                return [this.walletData.account];
            }
            const wallet = this.getWindowWallet();
            if (!wallet) {
                return [];
            }
            const silently = yield this.shouldPromptSilently(wallet);
            let data;
            this.logger.debug('[getConnectedAccounts] No existing account, attempting to connect with silent mode:', silently);
            try {
                ({ data } = yield this.prompt({
                    silently,
                }));
            }
            catch (error) {
                this.logger.debug(`[getConnectedAccounts] Silent connect errored out: ${error}`);
                return [];
            }
            this.logger.debug(`[getConnectedAccounts] Connect returned account: ${data === null || data === void 0 ? void 0 : data.account}`);
            if (!(data === null || data === void 0 ? void 0 : data.account)) {
                return [];
            }
            this.walletData = data;
            this.wallet = wallet;
            this.setupEventListeners();
            return [data.account];
        });
    }
    shouldPromptSilently(wallet) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            /**
             * In general, getConnectedAccounts should send a "silent" request to the wallet, meaning
             * no popup will be displayed to the user. However, in the case that the user comes back
             * to the dapp with a locked wallet, we do want to trigger a popup for the user to unlock
             * their wallet, but only if their wallet has still granted permission to the dapp to access
             * its data. That's what the following `wallet_getPermissions` RPC request does.
             */
            let silently = true;
            try {
                const permissions = yield wallet.request({
                    type: 'wallet_getPermissions',
                });
                if (permissions.includes(typesJs.WALLET_API.Permission.ACCOUNTS)) {
                    this.logger.debug('[getConnectedAccounts] Received `accounts` permission from wallet_getPermissions');
                    silently = false;
                }
            }
            catch (error) {
                this.logger.debug('[getConnectedAccounts] `wallet_getPermissions` threw error:', error);
            }
            return silently;
        });
    }
    getWindowWallet() {
        this.logger.debug('[getWindowWallet] Looking for wallet from window:', this.id);
        const wallet = window[`starknet_${this.id}`];
        this.logger.debug('[getWindowWallet] Lookup result:', wallet);
        return wallet;
    }
}

exports.Injected = Injected;
